Srinivas Dachepalli | 6305 730 633 | dachepallisrinivas@gmail.com

git repo link : https://github.com/dachepallisrinivas-1966/VirtueE

	Java Training
	--------------
	
		Core Java
			oops
			io streams
			collections
			exception handling
			Multi Threading

			
			
		Advanced Java
			dbms basics
			jdbc

			html
			css
			javascript
			
			servlets
			jsp
			jstl
			
			
		Java EE Frameworks

			hibernate
			spring - core, mvc
			spring boot

		Devops Tools
			GIT
			Maven
			Jenkins
			PMD / SonarLint / SonarQube	(Code Quality Analysis)		



	Eclipse 
	STS	(Spring Tool Suite)


	Coding Standards	(Best Practices)
	-----------------------------------------
	Code -> PMD -> generate a report and it assign marks also for your code.
		score < 85

		Code Smells

	1) naming convensions
		
		pascal notation
		camel notation
		uppercase notation
		lowercase notation


What is Java?
    is a high level strictly but partially object oriented programming language.

    + Strictly object oriented, as there is no way possible to implement any java application 
      without using OOP.,
    + Partially object oriented, as java supports native variables and native types which are
      not objects and classes

Who developed Java?
    Sun microsystems - James Gosling
    Oracle corp. is the present owner of Java language.
    (www.oracle.com)

Histroy And Evolution
----------------------------------------
    JDK Alpha and Beta (1995)
    JDK 1.0 (23rd Jan 1996)
    JDK 1.1 (19th Feb 1997)
    J2SE 1.2 (8th Dec 1998)                             Stable  
    J2SE 1.3 (8th May 2000)
    J2SE 1.4 (6th Feb 2002)                             Stable and Prominent
    J2SE 5.0 (30th Sep 2004)                            Stable, Prominent and Revolutionary
    Java SE 6 (11th Dec 2006)
    Java SE 7 (28th July 2011)
    Java SE 8 (18th Mar 2014)   (LTS)                   Stable and Most used on current day 
    Java SE 9 (21st Sep 2017)
    Java SE 10 (20th Mar 2018)
    Java SE 11 (Sep 2018)       (LTS)                   Stable and being adopted 
    Java SE 12 (Mar 2019)
    Java SE 13 (Sep 2019)
    Java SE 14 (Mar 2020)
    Java SE 15 (Sep 2020)

Java Distributions
-------------------------------------
        JRE                 Java Runtime Environment         
                                {Java Libraries,GC,JVM,Interpreter,ClassLoader,ByteCodeVerifier,JIT Compiler...}
        
        JDK                 Java (Standard) Development Kit    
                                {JRE, Development Tools, IDE Support}
Java program excution process:
------------------------------
text editor             -   source code     -   sample.java
compiler   (javac)      -   byte code       -   sample.class   
                    (byte code is not in the form of 0's & 1's)

is this sample.class is targeted to one particular O/S ?
NO.

sample.class is not an executable program.

byte code   --> JVM (Java Virtual Machine) -> JVM will convert the byte code 
        into native machine code (sequence of 0's & 1's understood by that particular
        O/S in which the program is executed)
        the program is executed.

        machine code is generated ON-THE-FLY.

Java is platform (means o/s) independent language.

is JDK  common for all O/S? -   (platform dependent)
    NO
is JRE  common for all O/S? -   (platform dependent)
    No
is JVM  common for all O/S? -   (platform dependent)
    NO

BYTE CODE is the only one component which is platform independent.

is Native machine code common for all O/S?
    NO


JDK   (Java Development Kit)  
    for developers.
    lot of tools to develop java applications.
    
    javac   -   java compiler
    java    -   interpreter
    javadoc -   to create HTML documentation of a project
    javap	-	disassembler
    jdb     -   java debugger
    appletviewer
	jar		


JRE   (Java Runtime Environment)
    JRE provide JVM + other libraries


Features of Java:
-----------------
1. platform independent
2. object oriented 
3. secured
        no explicit pointers in java.
        java programs run inside a special environment i.e. JVM.
        JVM will talk to O/S.
        (JVM is a collection of programs - class-loader, byte-code-verifier, garbage-collector)
4. robust
        means fault-tolerant, strong, vigour and healthy.
        a. exception handling
        b. automatic garbage collection
        c. strong type checking.

5. self-documented (open source)
    source code is visible to anyone.
6. architectural neutral
7. compiled and interpreted


CODING STANDARDS / BEST PRACTICES
1. maintain proper indentation.
2. naming conventions

Java Tokens
-----------
smallest element in the program.


1. identifier
        it is a name given to variables, class, method names, package etc.,

        variable, method names must follow camel notation
            first word is in lowercase.
            from the second word onwards use first letter of each word is in uppercase
            and rest in lower case.

            eg:
                length
                lengthOfRectangle
                circleArea

                acceptData()
                showMinMaxInArray()
        
        class names, file name and project must follow pascal notation.
        (first letter of each word in uppercase and the rest in lowercase).
            eg:
                ArrayIndexOutOfBoundsException
                RuntimeException
                String
				System


        package name
            always in lowercase
            there are often abbreviated.
            eg:
                io
                lang
                awt
                util
                
        constants
            always be in uppercase.
            it is a name given to literal.
            it is immutable.
            it is qualified with "final" keyword.
            they can be separated with an underscore.

            1. identifier
        it is a name given to variables, class, method names, package etc.,

        variable, method names must follow camel notation 
            first word is in lowercase.
            from the second word onwards use first letter of each word is in uppercase
            and rest in lower case.

            eg:
                length
                lengthOfRectangle
                circleArea

                acceptData()
                showMinMaxInArray()
        
        class names, file name and project must follow pascal notation.
        (first letter of each word in uppercase and the rest in lowercase).
            eg:
                ArrayIndexOutOfBoundsException
                RuntimeException
                String

        package name
            always in lowercase
            there are often abbreviated.
            eg:
                io
                lang
                awt
                util

        constants
            always be in uppercase.
            it is a name given to literal.
            it is immutable.
            it is qualified with "final" keyword.
            they can be separated with an underscore.

            final double PIE = 3.14;
                    PIE is a constant.
                    3.14 is literal

            final int PASS_MARKS = 35;
            final int MAX_MARKS = 100;
            final int BATCH_CAPACITY = 40;
            
2. keywords
        these are also reserved words.
        eg: if, switch, for, while
            int, float, double

3. operators
        unary operators
           which takes only one operand.
           ++   --  !    
        binary operators
            it takes two operands
            all the remaining 
        ternary operator
            which takes three operands.
            conditional operator


        a) arithmetic operators :   +   -   *   /   %
        b) relational operator  :   >   <   ==  >=  <=  !=
        c) logical operators    :   &&  ||  !
        d) conditional operator :   (condition) ? true-statment : false-statement;
        e) assignment operator  :   =   +=  -=  *=  /=  %=
        f) increment / decrement :  ++, --
        g) bitwise operators    :   refer your self.
        h) misc. operators      :
                []
                ()
                <>
                ,
                .
                ;
                instanceof
4. literals
        any hard coded value.

        doule area = 3.14*radius*radius;

        3.14 is literal.

        a) integer literals
                i) decimal literal      (0-9)
                    30, -5

                ii) binary literal      (0,1)
                    0b101011
                    int a = 0b101;

                    observe the 0b prefix here.

                iii) octal literal      (0-7)
                    int a = 0234;

                    observe 0 prefix.

                iv) hexadecimal literal (0-9, A-F)
                    int a = 0xABC;

                    observe 0x prefix
                
        b) floating point literals
                3.14
        c) character literals
                character is a single alphabet, single digit or single special symbol.
                it the charcater is enclosed within single quotes, it is character constant.

                'A'
                '7'
                '?'
                'AB'        invalid

                escape sequence characters:
                '\n'        new line character
                '\t'        tab


        d) string literals
                group of characters enclosed within double quotes.

                "srinivas"
                "49-53-20/25"
                "9247175823"
                "a"
				""              empty string

        e) boolean literals
                true, false


5. comments
        ignored by the compiler.

        end-of-line comment             //
        block comment                   /*  and */
        documentation comment           /** and */	
		
		double PIE = 3.14;
                    PIE is a constant.
                    3.14 is literal

            final int PASS_MARKS = 35;
            final int MAX_MARKS = 100;
            final int BATCH_CAPACITY = 40;
            
            double circumference = 2 * PIE * radius;

            keyword         double
            indentifier     circumference
            operator        =
            literal         2
            operator        *
            constant        PIE
            operator        *
            identifier      radius
            operator        ;


2. keywords
        these are also reserved words.
        eg: if, switch, for, while
            int, float, double

3. operators
        unary operators
           which takes only one operand.
           ++   --  !    
        binary operators
            it takes two operands
            all the remaining 
        ternary operator
            which takes three operands.
            conditional operator


        a) arithmetic operators :   +   -   *   /   %
        b) relational operator  :   >   <   ==  >=  <=  !=
        c) logical operators    :   &&  ||  !
        d) conditional operator :   (condition) ? true-statment : false-statement;
        e) assignment operator  :   =   +=  -=  *=  /=  %=
        f) increment / decrement :  ++, --
        g) bitwise operators    :   refer your self.
        h) misc. operators      :
                []
                ()
                <>
                ,
                .
                ;
                instanceof
4. literals
        any hard coded value.

        doule area = 3.14*radius*radius;

        3.14 is literal.

        a) integer literals
                i) decimal literal      (0-9)
                    30, -5

                ii) binary literal      (0,1)
                    0b101011
                    int a = 0b101;

                    observe the 0b prefix here.

                iii) octal literal      (0-7)
                    int a = 0234;

                    observe 0 prefix.

                iv) hexadecimal literal (0-9, A-F)
                    int a = 0xABC;

                    observe 0x prefix
                
        b) floating point literals
                3.14
        c) character literals
                character is a single alphabet, single digit or single special symbol.
                it the charcater is enclosed within single quotes, it is character constantt.

                'A'
                '7'
                '?'
                'AB'        invalid

                escape sequence characters:
                '\n'        new line character
                '\t'        tab


        d) string literals
                group of characters enclosed within double quotes.

                "srinivas"
                "49-53-20/25"
                "9247175823"
                "a"             
                ""              empty string

        e) boolean literals
                true, false

5. comments
        ignored by the compiler.

        end-of-line comment             //
        block comment                   /*  and */
        documentation comment           /** and */



                                data types   
                                ----------
    primitive types
        numeric 
            integral
                byte        1
                short       2
                int         4
                long        8
            floating-point
                float       4
                double      8
        non-numeric
                char        2
                boolean     1 bit   -   true, false
                
                in java, true means not 1 and
                false means not 0.
                true, false are literals.

                void    
                	generally used to specify the return type of a function.
    
    user-defined types
        class
        interface
        enum
		annotation
------------------------------------------------------------------------------------------------------------

Eclipse IDE   (Java SE and Java EE)

package:
    it is represented as folder in O/S.
    collection of classes, interfaces and sub packages.

package name:
    reverse of the domain name.
    1) com.vev.tsw.ui

in java, there is no function. we have methods only.

method overloading:
    when two methods have the same name but with different parfameter list.

control structures:
-------------------
if      : bi-directional decision making statement.
          data types permitted - int, long, short, byte
                                 float, double, char 

switch  : multi-directional decision making statement.
          [data types permitted - int, long, byte, short, char, float, double, boolean.]

for     : to repeat the statements for a finite number of times.
while   : to repeat the statements for a indefinite number of times.
do..while : to execute the statements atleast once

break
continue

labelled break and labelled continue - explore yourself


How do you accept data from the user?
--------------------------------------
    Scanner scan = new Scanner(System.in);

    System.in means accept data from the keyboard.
    
    nextInt()
    nextDouble()
    next()
    nextLine()

    Scanner class is available in java.util package.

    import java.util.Scanner;

    (or)

    type the fully qualified name.
    java.util.Scanner scan = new java.util.Scanner(System.in);


                                    arrays
                                    ------

linear collection of homogeneous data items stored under single name.
0 based index.
every array in java is an object.   
array is provide a special property (field) with the name "length", that return no. of cells
in the array.

if we try to access an element with an invalid index, leads to an exception.
"ArrayIndexOutOfBoundsException"

types of arrays:
-----------------
1) single dimension
2) multi-dimension
3) jagged 

single dimension:
-------------------
declaring:
----------
    datatype [] arrayName;
    (or)
    datatype arrayName[];

    just by declaring, no memory is allocated.

eg:
    int [] arr;

allocating memory:
------------------
    arrayName = new datatype[size];
eg:
    arr = new int[5];

    whenever we use "new" keyword, the memory is allocated dynamically and stored in a special
    memory area known as "heap".

declaring and allocating :
----------------------------
    datatype [] arrayName = new datatype[size];

eg:
    int [] arr = new int[5];

initialize an array:
---------------------
    int []  arr = {10,20,30,40,50}; 

enhanced for loop:
------------------
for  (datatype   var  :  array) {
    statement(s);
}

 there is no concept called "index".
	Enhanced for loop offer better performance than classic for loop.
	loop variable is not "int" unlike as in classic for loop.
	type of the loop variable is same as the type of array.
	We cannot process few elements in the array.

    it is used to traverse an entire array or a collection in forward-only direction.

write a program to find min, max of an array.

jagged array:
-------------
it is a multi-dimension array, contain different no. of columns in each row.

                                        Command Line Arguments
                                        ----------------------

public static void main(String [] args) {

}

we cannot define main method like this ..
public static void main() {

}
it is treated as another method.


command line arguments are used to give inputs (parameters) to the main() method.
it is another way of accepting data.

write a program to print all command-line arguments.

write a program to accept two numbers and an arithmetic operation (ADD, SUB, MUL, DIV)
using command line arguments and perform the operation and print the result.

is int a primitive type ?	
		yes`
is String a primitive type?
		no
		String is a pre-defined class, it is a user-defined type.

How do you convert data of String to primitive type int?
    Integer -> parseInt(String form int)
    eg: 
        "10"    =>  Integer.parseInt("10") => 10
        "5"     =>  Integer.parseInt("5") => 5
        "ADD"   =>  

    Double.parseDouble(String form double)

        "10.5"  =>  Double.parseDouble("10.5") => 10.5
    
    for all illegal value, we get NumberFormatException.


                                             VarArgs
                                             -------
write a function to return the sum of the values passed as arguments to the function.

 it represents indefinite number of arguments
    it is represented with ... (three dots)
    three dot symbol "ellipsis".

    we can pass any number of arguments while calling this type of function.

    Command Line Arguments can also be represeted as Variable Arguments.


                                        Method Overloading
                                        ---------------------
when two or more methods are having the same name but with different set of parameters ,
then it is said to be funcmethod overloading.

int area(int a, int b) {

}

int area(int a, double b) {

}       // allowed

int area(double a, int b) {

}   // allowed

double area(int a, int b) {

}   // NOT ALLOWED - return type is not considered


Arrays class: (java.util package)
----------------------------------
provide many util methods to simplify our programming.
explore these methods.

1) copyOf()
2) binarySearch()
3) sort()
4) fill()
5) toString()




equals()
    equals() compare references only

=========================================================================================================

                                    OOPS    (Object Oriented Programming System)
                                    --------------------------------------------
It is a programming paradigm (methodologies)
    + monolithic programming    (eg: assembly language, basic)
    + procedure oriented        (eg: cobol)
    + structured programming    (eg: 'C')
    + object oriented programming. (eg: C++, Java, C#, Python)

Advantages of OOP:
-------------------
+   code re-usability
+   security

class:  It is a user-defined datatype that represent an entity in terms of properties (data members) 
        and behaviours (methods)
        classes we are creating, also known as POJO (Plain Java Old Object).
        classes are also known as model, dto, entity etc.,
object: It is a runtime instance of class.

features of OOPS:
-----------------
+ encapsulation : providing setters and getters, so that other classes can access the private data
                  using these methods.
+ data hiding : making data members as private

+ abstraction : behaviour hiding
+ inheritance
+ polymorphism
+ persistence


class ClassName {
    [data members]
    [methods]
}

creating object:
----------------
ClassName   objectName;
objectName = new ClassName();

access specifiers (access modifiers):
---------------------------------------
1) default 
2) private  :   members under this access can be used only within the class in which they are defined
3) public   :   members under this access can be used in any class
4) protected

setters (mutators) and getters (accessors):


"this" reference:
--------------------
it refer to the "implied object".
implied object is the one through which a method is executed currently.


data members are stored separately for each object.
methods are stored only once and they can be accessed by all objects.


static members:
-----------------
static means "sharable".
1) static data members      (class variables)
    + when a data member is declared as "static", it is stored only once in the memory
      and that is shared across all objects of the class.

2) static methods
    + it allow only static data members or static methods
    + it can be called directly with the class name. no need to use any object to call static method.
    + "this" keyword is not allowed in a static method

3) static block
4) static class         (refer it)


constructor:
-------------
1) it is a special method which is automatically executed whenever an object is created.
2) it should have the same name as that of class.
3) if no constructor is written, java create a default constructor on it's own.
4) it can take parameters.
5) we cannot return any value from a constructor, and should not have return type as "void"
6) a class can have many constructors. this is known as "constructor overloading".

type constructors:
-------------------
1) default constructor   (no-parameter constructor)
2) parameter constructor
3) copy constructor : it is a special constructor that takes object of the same class as parameter.

OOAD  (Object Oriented Analysis and Design):
--------------------------------------------
UML  stands for Unified Modelling language

1) class diagram

==========================================================================================================

Inheritance:

	creating a new class (sub class) from an existing class (super class).
    sub class can make use of all features of super class as well as any extra features that are
    added to it.
    it represent "is-A" relation ship.
    it is mainly for code-reusability.

	types of inheritance:
	----------------------------
	1) simple	        A <- B
    2) hierarchical	    A <- B, A <- C
    3) multi-level      A <- B <- C
    4) multiple	        (not available for classes)
	
    the keyword "extends" is used to derive a sub class from a super class.
	java doesn't support multiple inheritance for classes that means a class can have only one
    superclass.
	
    Note:
    ------
	Inheritance will share only the definition but not the existence.

java.lang.Object class:
-----------------------
* It is a universal super class of every class in java (pre-defined or user-defined)

methods:
1) public String toString()
        it is written such a way that classname@hashcode is returned.

2) public int hashCode()
        return the hashcode in decimal representation

3) public boolean equals(Object obj)
        return whether two objects are equal or not.
        the default implementation is comparing references.


method overriding:
-------------------
when a sub class contain a method which has the same signature as that of another method of it's
super class, then the sub class method is said to be overriding method.

"@Override" annotation can be used on method overriding.
if overriding is not done propertly, @Override will raise an error.


constructor phenomenon:
----------------------------------
	when an object is created, the constructor of that class is called.

	when an object of sub class is created, super class constructor is called first and 
    then the sub class constructor is called. This hold true for any levels of inheritance.

	when a sub class object is created with

	i) default constructor		then the super class default constructor is called.
	ii) parameter constructor	then the super class default constructor is called.
	iii) copy constructor		then the super class default constructor is called.

"super" keyword:	("super" reference)
----------------------------------------------------
	1) it is used to call the constructor of super class from the constructor of sub class.
	2) This is used exclusively call a parameter constructor or copy constructor of the 
        super class from sub class constructor.
	3) if super() has to be used, it must be the first statement in the code block.
	4) this() and super() cannot be used at a time.	(mutually exclusive)
	5) "super" keyword can be used to call an overriding function of super class in the sub class.

class A {
    public A() {
        System.out.println("A");
    }
}
class B extends A {
    public B() {
        System.out.println("B");
    }
    public B(String msg) {
        System.out.println(msg);
    }
    public B(B obj) {
        System.out.println("copy constructor");
    }
}
class C extends B {
    public C() {
        System.out.println("C");
    }
}
class Main {
    public static void main(String [] args) {
        B obj2 = new B();               // A  B
        B obj3 = new B("hello");        // A  hello
        B obj4 = new B(obj2);           // A  copy constructor
    }
}


Abstract Polymorphism	(Abstraction)
---------------------------------------------------------
abstract means "incomplete or unclear". It is an idea but we don't know how to implement.
abstraction means "behaviour hiding".
abstraction is "disclosing only required details and hiding the background implementation".

abstract class:
--------------------
	It is a class which should not have objects allocated.

	School Automation
		School	=> Domain
		Teacher, Student, Principle	=> Domain Entities
	
		common properties	=>  

		Person ==> name, age, phone, address, date of birth, weight, height, blood group

		Teacher extends Person	    => salary, subject, 
		Principle extends Person	==>	....
		Student extends Person      ==> fee, class, section

        In this scenario, we never need to create an object for Person.
        so, Person class can be declared as an abstract.

	to make a class abstract, it must be defined with an "abstract" keyword.
	we cannot instantiate (create an object) an abstract class.

abstract method:
----------------------
	It is a method which do not have any implementation (i.e., definition)

   	eg:	abstract class Shape 
			abstract 	area()	: 
			abstract 	perimeter() :
			abstract	volume();


	    abstract class	Rectangle	extends	Shape {
			@Override
			area() {
				...
			}
			@Override
			perimeter() {
				..
			}
		}

		class	Cuboid	extends	Rectangle {
			@Override
			volume() {
				....
			}
		}

	1) an abstract method must be written only inside an abstract class.
	2) but an abstract class need not contain any abstract method.
	3) all sub classes of abstract class, must implement (override) all abstract methods. 
       if not, the sub class must also be marked as "abstract".

abstract class A {
    abstract void show();
}

class B extends A {
    @Override
    protected void show() {               
        System.out.println("B");
    }
}

class Test {
    public static void main(String [] args) {
        B obj = new B();
        obj.show();
    }
}

error:
    cannot reduce the visibility of the inherited method.

Type Casting:
-------------
	Converting one datatype to another.

	2 types.

	a) Narrowing	(demotion)		explicit
	b) Broadening	(promotion)		implicit


	primitive types:
	-------------------
	b) broadening:
	    -----------------
	int x = 45;
	double d = x;		(implicit)	- broadening

	double d2 = 67;		// OK
	int y = '@';		// OK

	char -> int -> double

	a) narrowing: (explicit):
	------------------------------
	int x = 45.0;		// error
	int x = (int)45.0;		// OK

	char ch = (char)156;	// OK


Referencing:
------------

	In inheritance, super class reference variable can hold sub class objects.
	Vice Versa  is NOT TRUE.

			                    Employee
			                        |
            --------------------------------------------
	        |					                        |
         Manager				                ContractEmployee
	        |
       Managing Director

	Employee emp1 = new Employee();	
	Employee emp2 = new Manager();		
	Employee emp3 = new ContractEmployee();	
    Employee emp4 = new ManagingDirector();	
	
	Manager m1 = new Manager();		
	Manager m2 = new ManagingDirector();	

	Manager m3 = new ContractEmployee();	
	ContractEmployee ce = new Employee();	


	user-defined data types:
	-----------------------------------------

	ContractEmployee ce1 = new Employee();		
	ContractEmployee ce2 = emp3;			

	ContractEmployee ce2 = (ContractEmployee)emp3	
	
	ContractEmployee ce3 = emp4;			
	ContractEmployee ce2 = (ContractEmployee)emp4	

	Manager m1 = (Manager)emp2;			
	Manager m2 = (Manager)emp3;			
	Manager m3 = (Manager)emp4;			

	
final keyword:
------------------
1) final class : it cannot be inherited.
2) final method : it cannot be overridden.
3) final variable : value of which cannot be modified. (constants)


Best Practices:
--------------------
whenever we create a constant, it is recommended to mark it as "public static final".
	final because it must be a constant.
	static because a constant will have only value for all objects of the class.
	public because however it cannot be modified.

class               : entity
abstract class      : semi-defined entity
interface           : ROLE (responsibility)

==================================================================================================

interfaces:
-----------
It is a user-defined datatype (like class) that represents a ROLE and can contain 
only abstract methods and static final variables (till JDK 1.7)
interface will not have properties.
we cannot instantiate (creating an object) an interface.



 interface                              Abstract Class
 ------------------                    -------------------
 no fields                              may have fields
 only public members                    any type of members
 
 represent Role                         represent Entity (semi-defined)
 
 one entity can 
 have any number of roles

 to achieve multiple inheritance


enum:
------
it is a user-defined datatype that represent possible values of a property (contain fixed set of constants)
"enum" stands for "enumeration".

It can be used for day of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY and SATURDAY) , 
directions (NORTH, SOUTH, EAST and WEST), Season (WINTER, SPRING, SUMMER, FALL), gender (MALE, FEMALE)   etc. 

The java enum constants are static and final implicitly. 

enum ensures type safety.

methods:
---------
1) values()
2) ordinal()
3) name()

 
static class

 Not all classes can be static.

 Java allows us to create one class inside another class, also known as inner class.
 only such inner class can be marked as static,
 and static inner classes are called nested classes.

 class Demo{
    class InnerClass{

    }

    static class NestedClass{

    }
 }


Java 8 enhancements to an interface.
------------------------------------
 default methods

 unlike method in a interface that are forced to be abstract,
 if a method is marked with keyword 'default', then the
 default method can have implementation

 interface A {
    public abstract void m1();
    public abstract void m2();


   default void m3() {
       // implementation code
   }

   static void m4() {

   }

 }

 class B implements A {
     @Overriding
     void m1() {

     }

     @Overiding
     void m2() {

     }

     @Override
     void m3() {
         // sub class specific
     }
 }

 B obj = new B();
 obj.m1()
 obj.m2()
 obj.m3()

 A.m4()     ==> since m4 is static method, we can call by using interface name.



 100 implementation classes 



						                Built-In Packages
						                ------------------
                                        (Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Thread
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
    Date        (deprecated)
    Calendar    (deprecated)
java.io
    BufferedReader

to use any class, we need to specify fully qualified class name.(eg: packagename.classname) 
or import them.

java.lang is the default package. it is automatically imported for every program.

1 java.lang.System class:
   -------------------------------

	class variables			              object
	-------------------				    ---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    String getEnvironmentVariable(String varName);
    void setEnvironmentVariable(String varName,String value);


java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            Math.sin(30)    =>  ???
            Math.sin(Math.toRadians(30))    =>  0.5

        double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            Math.ceil(11.2) => 12
		floor() : return previous integer
            Math.floor(11.9) => 11
		round() 
            Math.round(11.2) =>  11
            Math.round(11.9) =>  12

		abs()
		toRadians()
		toDegrees()

java.lang.String
---------------------
	String is immutable	(not modifiable).
    what is immutability?
        String s1 = "Hello";
        String s2 = new String("World");
        String s3 = s1 + s2;

	creating object:
	---------------------
	1) String	str;
	2) String	str = new String();
	3) String	str = "hello";
	4) String	str = new String("hello");
	5) String	str1 = str;
	6) String	str1 = new String(str);


	methods:
	-------------
	1) length()		2) toUpperCase()		3) toLowerCase()
	4) indexOf(String)	5) lastIndexOf(String)		6) startsWith(String)
	7) endsWith(String)	8) contains(String)		9) charAt(index)
	10) substring(start_index [, end_index] )		11) split()
	12) equals(String)	13) equalsIgnoreCase(String)	14) compareTo(String)
	15) valueOf()		16) format()        17) replace(old_char, new_char)

    18) join()  - JDK 1.8

    "+" string concatenation operator


String constant pool (String literal pool)
------------------------------------------
    This is a special memory used to store string constants.


java.lang.StringBuffer and java.lang.StringBuilder:
------------------------------------------------------------------
	StringBuffer is thread-safe. (synchronized)
	StringBuilder is not thread-safe.

	They are mutable (modifiable).

	a) capacity()
	b) append()
	c) insert()
	d) delete()
	e) reverse()

StringJoiner (jdk 1.8)
    used to join group of Strings.

    StringJoiner(delimiter)
    StringJoiner(delimiter, prefix, suffix)
    merge()

StringTokenizer (java.util)         -- Legacy Class
    to split the string into words based on the delimiter given.

    StringTokenizer(string, delimiter, boolean returnDelims)

    hasTokens()
    nextToken()

    Since it is a legacy class, we can use split() of String class, which offer better
    performance.



Wrapper Classes                     static method
---------------------               ---------------------------------
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long

every wrapper class provide two constants.
    MIN_VALUE 
    MAX_VALUE

 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing

static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice


Exception Handling
--------------------------------
    Exception is an object that represents a situation
    where the application broke down.

                java.lang.Throwable (i)
                        |
                        |
            ---------------------------------
            |                               |
            java.lang.Error         java.lang.Exception
                                            |
                                            |
                                    java.lang.RuntimeException
    
    Exception classes that are derived from Exception class - CHECKED
    Exception classes that are derived from RuntimeException class - UNCHECKED


    1) try : contain the code where the exception can be generated.
    2) catch : contain statements that are to be executed when the specified exception occurred.
            
            the most relevant exception classes mention first.
            least relevant exception mention next.

    a try block must follow an immediate catch block (or) a finally block.

            try {
                ..
            } finally {
                ...
            }

    a try can have many catch blocks.
    a try block can have another try block within it.

    3) finally : contain the code to be executed whether an exception or occurred or not.


    UnChecked Exceptions

        unchecked exceptions are 
        NOT INFORMED BY THE IDE / COMPILER. 

        we are not supposed to handle UnChecked Exceptions
        because they can be avoided through "Defensive programming".

            Employee emp;
            emp = new Employee();
            emp.setName("Lavanya"); //NullPointerException is avoided.

            public void processHike(Employee emp){
                if(emp!=null){
                    emp.setBasic(emp.getBasic()+10000); // NullPointerException is avoided
                }
            }

        
        Checked Exceptions

            all exception classes that are NOT
            derived from RuntimeException class are
            identified as Checked exceptions.
        
            if you do not handle checked exceptions, the compiler will give errors.

            if a method is supposed to raise
            checked exception, the compiler will
            force us to handle checked exceptions

            checked exceptions must be handled, they cannot be avoided.

            eg:
                download a file,                IOException
                database connection broken.     SQLException

                try{
                    ....the code that may raise an exception     
                } catch(Exception exp){
                    ..do the alternate or display a user understandable message.
                }

======================================================================================================
        User Defined Exceptions

            1. create a class which should be derived from java.lang.Exception or java.lang.RuntimeException
            2. write a constructor that takes a String parameter.
            3. call the super class constructor by passing this String to it.

            create a checked exception
            
            eg:
                class MyCheckedException extends Exception {
                    
                    public MyCheckedException(String errMsg){
                        super(errMsg);
                    }
                }

            create an unchecked exception

            1. create a class which should be derived from java.lang.RuntimeException
            2. write a constructor that takes a String parameter.
            3. call the super class constructor by passing this String to it.

            class MyUnCheckedException extends RuntimeException {
                  
                MyUnCheckedException(String errMsg){
                    super(errMsg);
                }
            }

            "throw" keyword is used to raise an exception
                throw new MyCheckedException("error message");

            "throws" keyword is used to tranfer (delegate) the exception handling responsibility
            from a method to its caller method.


    String getMessage()         (java.lang.Throwable)
	void printStackTrace()      (java.lang.Throwable)



JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

    try {
	    statement(s)
    } catch (Exception-1   |  Exception-2  |  Exception-3    obj) {
	    statement(s)
    }

b) try-with-resources

    try (declare closable resourceses here....){
                    ........................
    }catch(....){

    }

    the closable resource will be close automatically.

    a Resource has to implement java.lang.Closable interface
    to be recognized as closable.



java.time package (JDK 8) - DateTime API
----------------------------------------
	+ LocalDate
	+ LocalTime
	+ LocalDateTime
	+ DateTimeFormatter
	+ Duration
	+ Period


    LocalDate
        default format is yyyy-MM-dd.

        now() : static method that return system date.
        of(year, month, day)
        parse(string-form-date)

        getDayOfMonth()
        getDayOfYear()
        getMonthValue()
        getYear()

        plusDays()
        plusMonths()
        plusYears()

        now(), of(), parse() are known as "Factory method", which will return object of the same class.

    LocalTime
    LocalDateTime

    DateTimeFormatter
        format()
        ofPattern(formatString)
    Duration
    Period
        between(localDate1, localDate2)
        getDays()
        getMonths()
        getYears()

    ZoneId
        of()

    DateTimeFormatter                                        
        .ofPattern(String pattern);

            d           day                             
            dd          day with leading zeros          
            ddd         day in words

            M           month
            MM          month with leading zeros
            MMM         Three lettered Month name
            MMMM        comple month name

            yy , yyyy   Year

            h,hh        hour in 12 hr format
            H,HH        hour in 24 hr format

            mm          min

            ss          sec


                                   Regular Expressions
						           --------------------
                                    (java.util.regex)

A regular expression defines a search pattern for strings. The short form for regular expression 
is regex. 
The search pattern can be anything from a simple character, a fixed string or a complex 
expression containing special characters describing the pattern. 
The pattern defined by the regex may match one or several times or not at all for a 
given string.
Regular expressions can be used to search, edit and manipulate text.
It is mainly for validations.


	.	any single character
	\d	single digit from 0 - 9
	\D	single character except digit
	\s	space
	\S	single character except space
	[ ]	single character of given choice or range
		eg: 	[A-Z]           any uppercase alphabet
			    [abcdA-E]       a,b,c,d,A,B,C,D,E
			    [0-9]           any digit
	[^ ]	single character except within the range
		eg:	[^ 1-5]         any digit other than 1,2,3,4,5

occurance indicaters:
	
	?	0 to 1 time
	*	0 to any no. of times
	+	1 to any no. of times
	{ n }	exactly 'n' times.
	{ , m}	max. 'm' times and min. is '0'.
	{n, m}	min. 'n' times and max. is 'm' times.

eg:

	mobile number	"\d{10}"
	but in java, we must say "\\d{10}"

	but first digit cannot be 0. so , it must be given as ...	"[1-9]\\d{9}"

	vehicle number	eg: AP31 CK 9916
				        AP31CK   1
        [1-9]

		[A-Z]{2} \d{2} [A-Z]{2} \s\d{, 3}

	aadhar id		eg: 8414 6320 8422
		\d{4} \s \d{4} \s \d{4}
        [1-0]\d{3} \s \d{4} \s \d{4}

java.util.regex package:
------------------------------

a) Pattern class:		to represent regular expression.
-----------------------
	methods:
	-------------
	i)	public static 	Pattern 	compile(String   regexPattern)
			it checks whether any small part of pattern is matching or not.
	
b) Matcher class:
    methods:
    i) public static   boolean 	matches(pattern, String)
			it checks whether the entire string should exactly match the pattern.

split method (of java.lang.String)
    i) String [] split(String)
            will extract the String based on the pattern specified.


    public class RegExDemo {
        public static void main(String [] args) {
            String mobile = "9247175823";
            String mobile2 = "92471";


            // System.out.println(mobile.matches("[1-9][0-9]{9}"));
            // System.out.println(mobile.matches("[1-9][0-9]{9}"));

            Pattern mobP = Pattern.compile("[1-9][0-9]{9}");
            Matcher m1 = mobP.matcher(mobile);
            System.out.println(m1.matches());

            String passage = "I have to port 9247212540 into a new 9247212539";
            Matcher m2 = mobP.matcher(passage);
            System.out.println(m2.find());
        }
    }


                                    Generics
							        --------
These are called as ADT	(abstract data types)

when there is a logic which is indepedent of datatypes, then we can use ADT. 
eg: Sorting on int's, float's, double's or char's are same.
generics are implemented using angular bracktes. < >. The imaginary datatype is represented as T. 
eg: <T>.
if we have two imaginary datatypes then <T1, T2>

generics do not support primitive types.
T can be Book, Car, ComplexNumber, Employee etc.,
but not with int, char, float, double.
if it is inevitable, we may use Wrapper classes.


                                    Collection API (Collection Framework)
                                    --------------------------------------
                                            (java.util package)

API  (Application Programming Interface)
    It is a group of pre-defined interfaces, abstract classes.
    They provided implementation classes also.


It is a structured way of storing group of objects.

Collection means group of objects
There are two types of data structures

Linear:  
	Objects are stored in a linear fashion
	Objects can be numbered which we call as index
	Linear data structure supports index based operations.

Advantages:
	Linear data structure supports sequential access 
	Also Supports random access.

Non linear:
    Not in linear fashion so we do not have index here and 
    thus we cannot access them randomly.

Few of the classes are grouped into collection

Collections are divided into 3 parts:
	
	a) Declaration Part: 
	Here we have interfaces 

                               Collection API Diagram


                                       Iterable (I)
                                            |
                                       Collection (I)
                         ___________________________________________|________________________           
                        |                                           |                       |
                    List (I)                                    Set (I)               Queue (I)
        ________________|____________________                       |
        |                   |               |                       | HashSet (c)
    ArrayList (C)       LinkedList (C)    Vector (C)                | LinkedHashSet (c)
                                                                    | SortedSet (I)
                                                                        |
                                                                        |___ TreeSet (c)



	b) Implementation part: 
		Set<-- HashSet,LinkedHashSet.
		SortedSet<---------Treeset
		List<------ArrayList,LinkedList


	Collection interface methods:
       	{ size(), contains(object), add(object), remove(object) }

    List allow duplicate elements.
	ArrayList-->interally uses an expandable array to store the elements.
	If there are too many insertions and deletions LinkedList is used.
	If there are too many retrievals arrayList will perform better.
    Vector is a legacy class.

    ArrayList class
        DEFAULT_CAPACITY = 10
        elementData is an Object[] where the data of array list is stored.
        everytime the grow() method is called, the array is extended by 50%.
        newCapacity = oldCapacity + (oldCapacity >> 1);

        methods:
        --------
        add()
        isEmpty()
        size()
        remove(index)
        set(index, value)
        get(index)
        clear()
        equals()
        indexOf(value)
        lastIndexOf()
        toArray() : convert array list into an array.
        sort()

    LinkedList:
    -----------
        it is in the form of linked list.
        it can be used when you are having frequent updations.

        1) addFirst()
        2) addLast()
        3) removeFirst()
        4) removeLast()

    Vector:
    -------
        default capacity = 10
        when a new elements is added when the existing cells are filled, the capacity is
        DOUBLED.

    What is the difference between Vector and ArrayList?

    Iterator:
        which allows to iterate through a collection.

        iterator()
        hasNext()
        next()

    What is the difference between iterator and enhanced for?


Set:
-------
    Set will not allow duplicate elements where as list will allow the same.

	HashSet --> Order is undefined.
	LinkedHashSet--> Insertion Order
	TreeSet-> maintains sorted order
        null is not allowed in TreeSet. we get NullPointerException.

    index based retrieval is not possible.

Queue:
    FIFO    (first in, first out)
    insertions will happen at begining.
    deletions also happend at beginning.
PriorityQueue
ArrayDequeue



Map:
----
                        Map (I)
                          |
        ----------------------------------------------------------
        |                   |                       |
    HashMap             LinkedHashMap           SortedMap (I)
                                                    |
                                                 TreeMap



	Maps are used to store key-value pair data. (It is also called as Dictionary)
	In map, keys are not sorted in order
	In sorted map, keys are in sorted order 
    key cannot be duplicated.
    value can be duplicated.
	index based retrieval is not possible.
    value can be retrieved if a key is given.

    put(key,value)
    get(key)
    set(key,value)
    remove(key)
    size()
    contains(key)
    keySet() : return all keys
    values() : return all values
    containsKey()
    containsValue()
    entrySet() : entry means combination of key and value
    

    implementation classes:
        HashMap
        LinkedHashMap
        TreeMap
        HashTable       (Legacy class)


java.util.Collections class:
----------------------------
1) sort()
2) binarySearch(list, key)
3) fill(list, object)

    java.lang.Comparable interface:
    --------------------------------
    it contain only one abstract method
    
    public int compareTo(T object)

    The class should know how do you want to sort.  (intenally)
    The class must implement java.lang.Comparable interface.


Design Patterns:
----------------
    a) creational design Patterns
    b) behavioural design Patterns
    c) structural design patterns


Progamming-To-Interfaces: (Coding Standards)
--------------------------------------------
    Set<String> set = new HashSet<>();


There is a contract between equals() and hashcode() method.


Comparable interface:
----------------------
    It provide one abstract method.

    int  compareTo(T  o)

Comparator interface:
---------------------
    int compare(T o1, T o2)
================================================================================================

BDD : behavioural driven development
TDD : test driven development



                                        Multi-Layered Architecture
                                        --------------------------
ui
excep
pojo / model
service
dao


Presentation (UI)    <===========>      Service Layer         <========>     Data Access Layer     <=======>  DataStore
Layer                               (perform validations)                       (db logic)
(input/output)

DTO  (data transfer object)


Service Layer
    interface
    one or more implementation classes

    a) to perform validations
    b) to call corresponding dao layer methods

instead of real db, we will in-memory db like collections.

DAO Layer
    interface
    one or more implementations

    to store/retrieve/manage data in the datastore (collection/db etc.,)

Exceptions
    one or more user-defined exceptions (checked or unchecked)
    exceptions must be handled only in the presentation layer.
    if an exception occurred in any layer, propogate the exception to the previous layer.

UI
    display a menu to the end-user
    call service layer methods
    handle any exceptions

java.util.Collections class:
----------------------------
1) sort()
2) binarySearch(list, key)
3) fill(list, object)


                                    IOStreams   (java.io)
                                    ---------------------
                                    (Input Output Streams)  

stream :   flow of data from one point to another point.

java.io.File : used to convert the physical file in your file system to a java object.
               File means both file and directory (folder) w.r.t. O/S
methods:
    1) exists()
    2) isFile()
    3) isDirectory()
    4) File[] listFiles()
    5) getName()
    6) length()



IOStreams are divided into 2 categories.
1) text stream      (character steams)
        used to store plain text.

        Reader class
            FileReader
                int read()  : it will read one character at a time.
            BufferedReader
                String readLine() : it will read one line at a time
        Writer class
            FileWriter
            PrintWriter

    a file is known as resource.
    whenever a resource is opened, it must be closed before coming out of the program execution.


2) binary stream    (byte stream)
        used to store objects, images, videos and audios.

        InputStream class
            FileInputStream
            ObjectInputStream
                readObject()
        OutputStream class
            FileOutputStream
            ObjectOutputStream
                writeObject()

    Serialization       : storing an object into a file.
    De-Serialization    : retrieving an object from the file.

    To perform Serialization, the class should permit us.
    
    The class whose objects are to be stored in a file, must be inherited from
    java.io.Serializable interface.
    if not, we get NotSerializableException 

    Serializable is a null interface, means is does not contain methods.
    It is also called as Marker Interface.

    transient:
        it is a keyword (modifiers) that indicates the property should NOT be serialized.



                                    java.nio
                                    (New IO)
                                    --------
    Files
        lines()
        
    Path
    Paths






                                Functional Interface:  (jdk 1.8)
                                --------------------------------
    It is an interface that contain only one abstract method.
    it can be marked with @FunctionalInterface annotation.
    so that compiler will not allow you to add any extra methods later.


                                    Lambda Expressions (JDK 1.8)
                                    ----------------------------

it allows functonality to be passed as an argument to the function.
it is a replacement of Anonymous class that implements a functional interface.
(eg: Comparable, Runnable)

components of lambda expressions:
1) a comma-separated list of formal parameters enclosed in paranthesis
2) we can omit paranthesis if it is a single parameter
3) the arrow token ( -> ) is known as lambda operator
4) a body which consists of a single expression, or statement block.


Interface Arithmetic {
    int add(int a, int b);
    int diff(int a, int b);
}


class ArithmeticImpl implements Arithmetic {
    @Override 
    public int add(int a, int b) {
        return a+b;
    }
    @Override
    public int diff(int a, int b) {
        return a-b;
    }
}

public class Test {
    public static void main(String[] args) {
        ArithmeticImpl obj = new ArithmeticImpl();
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
    }
}


using Anonymous class:
----------------------
Interface Arithmetic {
    int add(int a, int b);
    int diff(int a, int b);
}

public class Test {
    public static void main(String[] args) {
       Arithmetic obj = new Arithmetic() {
            @Override 
            public int add(int a, int b) {
                return a+b;
            }
            @Override
            public int diff(int a, int b) {
                return a-b;
            }
        };
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
    }
}


Built-in functional interfaces
------------------------------
eg: Comparable, Comparator, Runnable

java.util.function package
--------------------------
interface           abstract method
-----------------------------------------------------------------
Consumer<T>         void    accept(T)
Supplier<T>         T       get()
Predicate<T>        boolean test(T)
Function<T,R>       R       apply(T)
UnaryOperator<T>    T       apply(T)
BinaryOperator<T>   T       apply(T,T)


                                    Streams
                                    -------
                                (java.util.stream)

Stream is a flow of data from a data source.
where data source can be an array or any other collection.
streams once consumed we cannot be use it again.

1) java.util.stream.Stream.of(array);
    create a stream taken array as a data source.
2) java.util.Collection::stream()
    create a stream taken any collection like list,set as a data source.

    Stream s1 = Stream.of(array);
    Stream s2 = list.stream();
    Stream s3 = set.stream();


stream() and parallelStream() ?
    stream() will operate on one core.
    parallelStream() will operate on multiple cores. (hardware related)


java.util.stream.Stream methods (operators):
operators    accepts         returns             does                                       type
-------------------------------------------------------------------------------------------------------
1) forEach      a consumer      void                executes the consumer on each element   terminal operation
2) collect      a Collector     a Collection        gather all elments in the stream into   terminal operation
                                                    collection.
3) reduce       BinaryOperator  java.util.Optional  execute the binary operator on each     terminal operation
                                                    pair of element in the stream.

                what is a Collector?
                    Collectors.toList()
                    Collectors.toSet()
                    Collectors.toMap(KeyMaper, ValueMapper)

        List<Employee> emps = new ArrayList<>();
        emps.add(new Employee(....));
        emps.add(new Employee(....));

        (or)

        List<Employee> emps = Arrays.asList(
            new Employee(...),
            new Employee(...),
            new Employee(...),
            ...
        );

        for(Employee employee : emps) {
            System.out.println(employee);
        }

        (or)

        emps.stream.forEach(e -> System.out.println(e));

        println is also a consumer. so, we can simplify ... using method reference
        emps.stream.forEach(System.out::println);
        here we are not calling println, rather we are passing println function to System.out
        and on every element println is executed.



        create a map with empid as key and emp object as value:
        -------------------------------------------------------
        Map<Integer, Employee> empMap = 
            emps.stream().collect(Collectors.toMap(e -> e.getEmpId(), e -> e));
        System.out.println(empMap);

        create a set from array list:
        -----------------------------
        Set<Employee> empSet = emps.stream().collect(Collectors.toSet());
        System.out.println(empSet);


        Stream s = Stream.of(new int[] {1,2,3,4,5,6});
        Optional<Integer> sum = s.reduce( (x,y) -> x+y);
        System.out.println(sum.isPresent() ? sum : null);

        Optional<Employee> costlyEmployee = emps.stream().reduce( 
            (e1, e2) -> e1.getSalary() > e2.getSalary() ? e1 : e2);
        System.out.println(costlyEmployee.isPresent() ? costlyEmployee.get() : null);
        
        why Optional?
            it helps to avoid NULL POINTER EXCEPTION.

        Optional<Employee> senior = emps.stream().reduce( 
            (e1, e2) -> e1.getHireDate().isBefore(e2.getHireDate()) ? e1 : e2);
        System.out.println(senior.isPresent() ? senior.get() : null);


    filter(Predicate)                   :   intermediate operation
    map(Functional transformer)         :   intermediate operation
    sorted(BinaryOperator)              :   intermediate operation   
    flatMap(Functional transformer)     :   intermediate operation


StreamAPIDemo.java          (vam-repo)       
    books.stream().forEach(System.out::println);

    books.stream().forEach( (b) -> {
        b.setPrice(b.getPrice()*2);
    });
    books.stream().forEach(System.out::println);


int [] a = {1,2,3,4,5};
Stream s = Stream.of(a);
BinaryOperator<Integer> bo = (a,b) -> a+b;
s.reduce(o);        // return Optional<Integer> = 15
    ((((1+2)+3)+4)+5) = 15

to see a latest published book :
    Optional<Book> latestPublishedBook = books.stream().reduce( (b1,b2) -> b1.getDateOfPublished().isAfter(b2.getDateOfPublished()) ? b1 : b2));
    System.out.println(latestPublishedBook.get());  

to see list of books whose price is less than 4000 :
    books.stream().filter( b -> b.getPrice() <= 4000).forEach(System.out::println);

to convert list into set :
    Set<book> bookSet = books.stream().collect(Collectors.toSet());
    System.out.println(bookSet);


    List<Book> lessPricedBooks = books.stream()
                                    .filter( b -> b.getPrice() <= 4000)
                                    .collect(Collectors.toList());
        System.out.println(lessPricedBooks)
map :
    int [] a = {1,2,3,4,5};
    Stream.of(a).map( n->n*n ).forEach(System.out::println);        // 1,4,9,16,25
    Stream.of(a).map( n->"Hello"+n).forEach(System.out.println);
    
    List<String> bookNames = books.stream().map( b -> b.getName()).collect(Collectors.toList());
    System.out.println(bookNames);
    (or)
    List<String> bookNames = books.stream().map(Book::getName).collect(Collectors.toList());
    System.out.println(bookNames);

sorted :
    using comparable :
    books.stream().sorted().forEach(System.out::println);   
    
    using comparator :
    books.stream().sorted( (b1,b2) -> b1.getDateOfPublished().compareTo(b2.getDateOfPublished()))
            .forEach(System.out::println);

flatMap :
    if we have an array of arrays (stream of streams), and we want to flaten that into a 
    single array (or stream), flatMap is used.

    add a property is called authors.
    private String[] authors;
    add another constructor that takes authors along with other properties.
    generate getters and setters for authors.
    regenerate hashcode, equals and toString methods.

    in the main program, create book objects using the newly added constructor and provide
    authors of each book along with other details.

    books.stream().map(Book::getAuthors)
        .flatMap(b -> Stream.of(b.getAuthors()))
        .distinct()
        .forEach(System.out::println);




List<Employee>  employeeList = new ArrayList<>();
employeeList.add(new Employee(....));
...


for(Employee employee : employeeList) {
    if (employee.getSalary() >= 5000) {
        System.out.println(employee);
    }
}

(or)

Stream<Employee>  filteredStream = employeeList.stream()
            .filter(emp -> emp.getSalary() >= 500);
filteredStream.forEach(emp -> System.out.println(emp));


methods:
--------
boolean                         allMatch(Predicate predicate)   
boolean                         anyMatch(Predicate predicate)
long                            count()
Stream<T>                       distinct()
static<T> Stream<T>             empty()
Stream<T>                       filter(Predicate predicate)
Optional<T>                     findAny()
Optional<T>                     findFirst()
void                            forEach(Consumer<T> action)
Stream<T>                       limit(size)
Stream<T>                       skip(size)
Stream                          map(Function )
Option<T>                       max(Comparator )
Option<T>                       min(Comparator )
Stream<T>                       sorted()
Stream<T>                       sorted(Comparator )
Object[]                        toArray()

==============================================================================================================

                                                    Module-2
                                                    ---------
oracle 11g express edition download link:
----------------------
https://www.youwindowsworld.com/en/downloads/database/oracle/oracle-database-express-edition-11g-release-2-windows-64-bit/download-256-oracle-database-express-edition-11g-release-2-64-bit                                                    



DBMS (Database Management System)
---------------------------------
data            : collection of raw facts 
data processing : inserting/deleting/modifying/sorting/searching the data
information     : output of data processing


6 subjects - individual subject marks are given to class teacher     (data)
progress report - individual subject marks, total marks, grade, rank (information)

account statments (information) which is madeup of transactions (data)

database    :   repository of data. 
                collection of database objects.
database objects : table, views, indexes, synonyms, sequences etc.,
database management system (dbms) : collection of tools that are used to manage the database.


DBMS models:
------------
1) hierarchical     (HDBMS)
2) network          (NDBMS)
3) relational       (RDBMS)

RDBMS Products:
---------------
Oracle, MySQL, PostGre SQL      (Java Development)
DB2, MS SQL Server

Oracle 5            MS-DOS Based    
Oracle 6            MS-DOS Based

Oracle 7, 7.1, 8
Oracle 8i           (i stands for internet)

Oracle 9i           widely used

Oracle 10g          Express Editions  (free - learners / trainers / colleges)
Oracle 11g      -   g for grid computing

Oracle 12c      -   c for cloud computing     

Oracle 19c


default user names:  (admin accounts)
system
sys


Database users:
---------------
1) End users  (Naive Users)
2) Application Developers
3) Adminstrators - installing, creating and managing user accounts, managing databases, performance tuning

from oracle 10g onwards, they offer one special account (contain sample tables)
user name : hr
password : hr

All RDBMS products use only one language SQL.
SQL stands for Structured Query Language.


SQL Commands are classified as ...
1) DDL  (data definition language) commands     [CREATE | RENAME | ALTER | TRUNCATE | DROP]
2) DML  (data manipulation)                     [INSERT | UPDATE | DELETE]
3) DCL  (data control)                          [GRANT | REVOKE]
4) DQL / DRL  (data query / data retrieval)     [SELECT]
5) TCL  (Transaction control)                   [COMMIT | ROLLBACK | SAVEPOINT]


Features of SQL:
----------------
1) SQL is Case InSensitive Language.
2) Clauses must be given in different lines.
3) Table names are plural.
4) SQL commands must be terminated by a semi-colon(;)

creating a table:
-----------------
CREATE   TABLE   tablename
(columnname    datatype,
 columnname    datatype,
 .....
);

rules for constructing an identifier name:
------------------------------------------
identifier name can be the name of table, column etc.,

1. max. of 30 characters
2. must begin with an alphabet.
3. can contain digits also. (this is not recommended)
4. except undescores, no other special symbol is allowed.
5. reserved words are not allowed.


SQL Data types:
----------------
1) CHAR([w])    : to store fixed-length values, whose width can be max. of 2000 characters.
                  default width 1.  (spaces are embedded)
2) VARCHAR(w)   : to store varying-length values, whose width can be max. of  4000 characters.
   VARCHAR2(w)

   till oracle 6 version, it was called as VARCHAR.
   later on oracle calling it as VARCHAR2.

3) NUMBER(w [,s])   numeric values upto width 'w' and scale 's'.
4) DATE         : to store date values within range Jan 1 st 4712 B.C. to 31 st Dec 9999 A.D.
                  default date format is dd-mon-yyyy   (eg: 04-oct-2021)

5) LONG         : to store large amount of data upto 2GB.
                  only one LONG column is allowed per table.
6) RAW          : to store binary data such as images, pictures upto 2000 bytes.
7) LONG RAW     : LONG + RAW

INSERT: 
1) to add new rows.
2) character and date literals must be enclosed within single quotes.

syntax:
-------
INSERT   INTO  tablename  [ (col-1, col-2, ...) ]
VALUES   (value-1, value-2, ....);

SELECT:
-------
to retrieve data from the table.
using SELECT, we can perform RELATIONAL ALGEBRA Operations.

1. projection   :   selecting few columns
2. restriction  :   selecting few rows that meet a criteria
3. union
4. intersect
5. minus (difference)
6. join         :   retreiving data from multiple tables that share relation ship
7. cartesian product (cross-product)

syntax:
-------
SELECT   column-list/*
FROM     tablename;

UPDATE:
--------
TO MODIFY ROWS.

UPDATE   tablename
SET  col-1 = value-1  [, col-2 = value-2 ,....]
[WHERE  condition];


DELETE:
-------
to delete rows.

DELETE  FROM  tablename
[WHERE   condition];


TRUNCATE  TABLE:
-----------------
to delete all rows from the table 

TRUNCATE  TABLE  tablename;


DROP TABLE:
-----------
DROP TABLE tablename;

                                Normalization:  (database design)
                                ----------------------------------
is all about spliting a table into smaller multiple tables.

1NF   : multi-valued columns are not allowed and should have primary key
2NF   : 1NF && functional dependency
3NF   : 2NF && not transitive dependency


                                    Integrity Constraints
                                    ---------------------
These are conditions given for a column (or) combination of columns.
During DML operations, if we violate any of these rules, oracle server generate constraint-violation
error messages.

constraints:
----------------------
1) NOT NULL
2) UNIQUE
3) PRIMARY KEY
4) FOREIGN KEY   (REFERENCES)
5) CHECK  (condition)

constraint options:
---------------------
do not allow constraint names.

1) DEFAULT

primary key:   (not null && unique)
-----------------------------------------
1) is used to identify uniquely each row
2) a table can have only one primary key
3) null values are not allowed
4) duplicate values are not allowed
5) it is a single column or combination of columns


depts - { deptno - (p), dname, loc }

foreign key :
----------------------------------------
1) used to establish a relation between parent (master | independent) and child tables (dependent)
2) it always present in child table
3) it is a column or combination of columns   
4) null values are allowed
5) duplicates are also allowed.
6) every foreign key must be defined as primary key or unique key in it's parent table.
7) a table can have many foreign key

emps - { empno - (p), ename, salary - min. is 5000, deptno - (f) }


ALTER   TABLE:
===============
to modify the structure of the table.

WE CAN ADD
    new columns
    new constraints
WE CAN REMOVE
    existing columns
    existing constraints
WE CAN MODIFY
    column types, size

syntax:
-------
ALTER   TABLE  tablename
[ADD | MODIFY | DROP | RENAME]   column specification;


SELECT:
-------
SELECT command can perform the following 4 operations.
a) arithmetic operations
b) column aliases
    alternate name given for columns in the output of SELECT command.
    column aliases must be enclosed within double quotes unless it is a single word.
    optionally we may use "AS" keyword after the column name in the SELECT list.

c) concatenated columns
    combining two or more columns.
    using concatenation operator ( || )   - double pipe symbol
d) literals
    literals must be enclosed within single quotes.
    it is repeated for each row in the output of the select command.

null:
-----
if a column lacks it's value during insertion, it is said to be null.
null means either unassigned, unpredicted or undetermined.
null is not same as ZERO.
it occupy ONE BYTE in the oracle internal storage overhead.
any operation performed with NULL value, leads to NULL result.

nvl():
-------
    nvl(col/val/expr, non-null-value)

distinct qualifier:
-------------------
    to eliminate duplicate rows in the output.

operators:
-----------
1) arithmetic operators
    +   -   *   /   
2) relational operators
    >   <   =   >=  <=  != (or) <>
3) logical operators
    and     or  not
4) sql operators
        a) BETWEEN   value-1  AND  value-2
        b) IN  (value-1, value-2, ....)
        c) LIKE  'character pattern'
                i) %    replace 0 or more unknown characters
                ii) _   replace single unknown character
        d) IS NULL

        e) NOT BETWEEN   value-1  AND  value-2
        f) NOT IN  (value-1, value-2, ....)
        g) NOT LIKE  'character pattern'
                i) %    replace 0 or more unknown characters
                ii) _   replace single unknown character
        d) IS NOT NULL

ORDER BY:
---------
the order of retrieval of rows using SELECT statement is insignificant. 
However we can use ORDER BY clause to specify the sorting order. 
If used, it must be the last clause in the SELECT statement.

Transaction Control Language (TCL) Commands:
--------------------------------------------
Transaction is a logical unit of workdone. (LUW).
a transaction may be 1 or multiple sql commands.
there are 2 types.
a) DDL transaction :    one ddl command makes up one transaction.
                        it is automatically committed.
b) DML transaction :    may contain one or multiple commands.

commit :    to save the current transaction
rollback :  to cancel the current transaction.




Library Functions:
------------------
1) mathematical functions
    a) power(x, y)
    b) sqrt(n)
    c) abs(n)
    d) round()
    e) trunc()
    f) ceil()
    g) floor()

2) character functions
    a) length()
    b) upper()
    c) lower()
    d) initcap()

3) date functions
    sysdate : return the system date
    
    a) months_between(date-1, date-2)
    b) last_day(date)
    c) next_day(date, 'week day name')

4) conversion functions
    a) to_char(date, 'date picture')

5) functions that accept any datatype as input
    a) decode (col/expr, search-1, result-1, search-2, result-2, ...., default)
    
6) group functions (aggregate functions)
    a) sum()
    b) avg()
    c) min()
    d) max()
    e) count()


GROUP BY clause:
    used to divide rows into groups.
    on each group we can get aggregate information.

HAVING clause:
    used to filter rows after grouping.

JOIN:
    to retrieve data from multiple related tables.


select employee_id, department_id, department_name, salary
from employees
join departments
using (department_id);

select employee_id, E.department_id, department_name, salary
from employees E
join departments D
on (E.department_id = D.department_id);


left outer join:
    to get the missing rows in join operator.

    select employee_id, department_id, department_name, salary
    from employees
    left outer join departments
    using (department_id);



sub query:
----------
select col-1, col-2, ...
from  tablename
where col = (select col from tablename);

the sub query (inner query ) is executed first. the result is passed to the main query (outer query).

there are 2 types.
a) single-row sub query
        use =, >, < as comparision operator`
b) multi-row sub query
        use IN, > ANY, < ANY, > ALL, < ALL operators.



views:
-------
a view is a virtual table.
it is like a window through which we can see the data from an underlying table known as base table.
a view does not contain any data on it's own.
it is stored as select statement only.


create view highly_paid_employees
as
select employee_id, first_name, salary
from employees
where salary > 10000;

select * from highly_paid_employees;


sequence:
---------
to generate sequence numbers.

create sequence department_id_seq
start with 280
increment by 10
maxvalue is 350;

nextval pseudo column is used to generate next value from the sequence.
currval pseudo column is used to retrieve current value from the sequence.

index:
------
it is meant for faster searching.
index is created automatically for primary key column.

create index job_id_idx
on employees(job_id);

select * from employees
where job_id = 'IT_PROG';




PL SQL
------
Procedurel Language of SQL.

PL SQL architecture:
--------------------
    diagram.

PL/SQL block contain ..
    a) SQL commands
    b) PL/SQL constructs


PL/SQL blocks are of 2 types.
a) anonymous block
b) named blocks.

structure of PL/SQL anonymous block:
------------------------------------
DECLARE
    variable declarations;
BEGIN
    statement(s);
EXCEPTION
    WHEN  exception_id   THEN
        statement(s);
END;
        
PL/SQL datatypes:
-------------------
number, varchar, date, long, boolean

SELECT statement in PL/SQL:
---------------------------
SELECT   col-1, col-2, ...
INTO     var-1, var-2, ...
FROM     tablename
[WHERE   condition]
[GROUP   BY  col-1, col-2, ...]
[HAVING  condition]
[ORDER   BY col-1, col-2, ...];

SELECT statement in PL/SQL should return only one row.
otherwise it leads to exception


pre-defined (built-in) exception id:
-------------------------------------
1) NO_DATA_FOUND
2) TOO_MANY_ROWS


control structures:

IF  condition  THEN
    statement(s)
ELSE
    statement(s)
END  IF;


IF  condition  THEN
    statement(s)
ELSIF  condition  THEN
    statement(s)
ELSIF  condition  THEN
    statement(s)
....    ....    ...
ELSE
    statement(s)
END  IF;



CASE  
    WHEN  condition-1  THEN   statement(s)
    WHEN  condition-1  THEN   statement(s)
    WHEN  condition-1  THEN   statement(s)
    ELSE  statement(s)
END  CASE


FOR   control_variable  IN   start_value .. end_value
LOOP
    statement(s);
    [EXIT];
END LOOP;


WHILE   condition
LOOP
    statement(s);
    [EXIT]
END LOOP;



-- display employee details whose employee id is 102
-- calculate bonus
-- if salary is more than 15000 then bonus is 15%
-- if salary is more than 10000 then bonus is 8%
-- otherwise bonus is 5%

SET SERVEROUTPUT ON
DECLARE
    v_employee_id       number(4);
    v_first_name        varchar2(10);
    v_salary            number(5);
    v_bonus             number(7,2);
    v_percent           number(2);
BEGIN
    SELECT  employee_id, first_name, salary
    INTO    v_employee_id, v_first_name, v_salary
    FROM    employees
    WHERE   employee_id =  102;
    
--    if v_salary > 15000 then
--        v_bonus := v_salary * 15/100;
--    elsif v_salary > 10000 then
--            v_bonus := v_salary * 8 / 100;
--    else
--            v_bonus := v_salary * 5/100;
--    end if;

    CASE  
        WHEN  v_salary > 15000 THEN v_percent := 15;
        WHEN  v_salary > 10000 THEN v_percent := 8;
        ELSE v_percent := 5;
    END CASE;
    
    v_bonus := v_salary * v_percent/100;
    
    dbms_output.put_line('Employee Id = ' || v_employee_id);
    dbms_output.put_line('Employee Name = ' || v_first_name);
    dbms_output.put_line('Salary = ' || v_salary);
    dbms_output.put_line('Bonus = ' || v_bonus);
    
EXCEPTION
    WHEN  NO_DATA_FOUND THEN
        dbms_output.put_line('No employee with id 1002');
    WHEN  TOO_MANY_ROWS  THEN
        dbms_output.put_line('More employees found');
END;


CURSOR:
-------
    +   it is private sql area in which rows returned by pl/sql select statement are stored.

    +   declare the cursor
        -   the select statement associated to the cursor is validated
    +   open the cursor
        -   select statement is executed and data returned to pl/sql memory
    +   fetch one row at a time and process the row
    +   close the cursor when all rows are processed

BEGIN
    FOR   i   IN   (SELECT  employee_id, first_name, job_id, salary
                    FROM    employees
                    WHERE   job_id = 'IT_PROG')    
    LOOP
        dbms_output.put_line('Employee Id = ' || i.employee_id);
        dbms_output.put_line('First Name = ' || i.first_name);
        dbms_output.put_line('Job Id = ' || i.job_id);
        dbms_output.put_line('Salary = ' || i.salary);
        dbms_output.put_line('---------------------------------------------------------------');
    END  LOOP;
END;


BEGIN
    FOR I IN ( SELECT  department_id, trunc(avg(salary),2) as average_salary
                FROM    employees
                GROUP   BY  department_id )
    LOOP
        dbms_output.put_line(i.department_id || ' -> ' || i.average_salary);
    END LOOP;
END;


Named Blocks: (Stored SubPrograms):
------------------------------------
There are 2 types.
a) stored procedure
b) stored function

A stored procedure is a PL/SQL block stored in the database with a name.
A stored procedure can be called from client programs such as PL/SQL, Java and .Net Programs.

Advantages:
-----------------
a) Reduced Network Traffic 	-   as name only passed from client to server
b) Better Performance 		-   as it is loaded and stays in memory (SGA - Shared Global Area) so that 
                                subsequent invocations can make use of procedure in memory. Procedures are 
                                also stored in compiled format, which makes them run faster.
c) Easy Maintenance		    -   as a change of business logic needs only a change to procedure in the database. 
                                All client applications can immediately use new business logic.
d) Security				    -   as it is possible to grant privilege to users to execute procedure even though 
                                no privilege is granted on table, there is no need to grant privileges on the 
                                table to others.



CREATE OR REPLACE PROCEDURE raisesal (p_empno  IN  emp888.empno%type,
                                      p_per    IN  number)
IS
        NO_EMPLOYEE     EXCEPTION;
BEGIN
    	UPDATE   emp888
	    SET	  basic = basic + basic*p_per/100
	    WHERE	empno = p_empno;

        IF SQL%ROWCOUNT = 1 THEN
           COMMIT;
        ELSE
           raise NO_EMPLOYEE;
        END IF;
EXCEPTION
        WHEN NO_EMPLOYEE THEN
             dbms_output.put_line('No Employee');
END;


begin
   raisesal(1, 10);
end;


stored function:
----------------
it will return one value.

CREATE  OR REPLACE  FUNCTION getname (p_employee_id  employees.employee_id%type)
RETURN  employees.first_name%type
IS
	v_first_name	employees.first_name%type;
BEGIN
	SELECT	first_name
	INTO	v_first_name
	FROM	employees
	WHERE	employee_id = p_employee_id;
	
    RETURN	v_first_name;
EXCEPTION
        WHEN  NO_DATA_FOUND THEN
             RETURN 'Employee Not Found';
END;


packages:
---------
    collection of stored procedures, stored functions, user defined types etc.,




                                        JDBC
                            (Java DataBase Connectivity)

Java Application                                                    Database (RDBMS)

data is stored in the form                                      data is stored in the form 
of OBJECT.                                                      of TABLE.

                                    JDBC API
                        (JDBC Application Programming Interface)
                                (java.sql package)


API -   collection of interfaces, abstract classes.
Sun microsystems was not providing any implementation classes.
implementation classes should be provided by the DB Vendors (oracle, mysql, ms sql server etc.,)
implementation classes are known as JDBC Drivers.
implementation classes are generally supplied in the form of ".jar" (java archive) file(s).


steps:
------
1) load the jdbc Driver     (optional from JDBC 4.0)
2) establish connection
3) fetch data from the database
4) close the connection

interfaces:
+   DatabaseMetaData
    -   getDatabaseProductName()
    -   getDatabaseProductVersion()
+   Connection
    -   createStatement()
    -   prepareStatement(sql)
    -   getMetaData();
+   Statement
+   PreparedStatement
+   ResultSet
    -   next()  : to read one row at a time from the result set.
+   CallableStatement
    -   to call stored sub programs

LOB     (Large Object)
    CLOB        (Character Large Object)
    BLOB        (Binary Large Object)



                                        Maven
                                        -----
It is a build tool.
It is an automation tool for build process.

It will download necessary jar files.

Maven maintain a central repo that contain necrssary jar files for java developers.
(mvnrepository.com)

Every Maven project pom.xml. (project object model).
Here we have to specify dependencies.

run as -> Maven Install
run as -> Maven Clean

Maven goals:
+   clean
+   install
+   build
+   compile
+   test


                                        Logging
                                        -------
log4j       

1. define logger
2. create a layout
3. create an appender and link the layout to it
4. link the appender to logger




































 




























































































