Srinivas Dachepalli | 6305 730 633 | dachepallisrinivas@gmail.com

git repo link : https://github.com/dachepallisrinivas-1966/VirtueE

	Java Training
	--------------
	
		Core Java
			oops
			io streams
			collections
			exception handling
			Multi Threading

			
			
		Advanced Java
			dbms basics
			jdbc

			html
			css
			javascript
			
			servlets
			jsp
			jstl
			
			
		Java EE Frameworks

			hibernate
			spring - core, mvc
			spring boot

		Devops Tools
			GIT
			Maven
			Jenkins
			PMD / SonarLint / SonarQube	(Code Quality Analysis)		



	Eclipse 
	STS	(Spring Tool Suite)


	Coding Standards	(Best Practices)
	-----------------------------------------
	Code -> PMD -> generate a report and it assign marks also for your code.
		score < 85

		Code Smells

	1) naming convensions
		
		pascal notation
		camel notation
		uppercase notation
		lowercase notation


What is Java?
    is a high level strictly but partially object oriented programming language.

    + Strictly object oriented, as there is no way possible to implement any java application 
      without using OOP.,
    + Partially object oriented, as java supports native variables and native types which are
      not objects and classes

Who developed Java?
    Sun microsystems - James Gosling
    Oracle corp. is the present owner of Java language.
    (www.oracle.com)

Histroy And Evolution
----------------------------------------
    JDK Alpha and Beta (1995)
    JDK 1.0 (23rd Jan 1996)
    JDK 1.1 (19th Feb 1997)
    J2SE 1.2 (8th Dec 1998)                             Stable  
    J2SE 1.3 (8th May 2000)
    J2SE 1.4 (6th Feb 2002)                             Stable and Prominent
    J2SE 5.0 (30th Sep 2004)                            Stable, Prominent and Revolutionary
    Java SE 6 (11th Dec 2006)
    Java SE 7 (28th July 2011)
    Java SE 8 (18th Mar 2014)   (LTS)                   Stable and Most used on current day 
    Java SE 9 (21st Sep 2017)
    Java SE 10 (20th Mar 2018)
    Java SE 11 (Sep 2018)       (LTS)                   Stable and being adopted 
    Java SE 12 (Mar 2019)
    Java SE 13 (Sep 2019)
    Java SE 14 (Mar 2020)
    Java SE 15 (Sep 2020)

Java Distributions
-------------------------------------
        JRE                 Java Runtime Environment         
                                {Java Libraries,GC,JVM,Interpreter,ClassLoader,ByteCodeVerifier,JIT Compiler...}
        
        JDK                 Java (Standard) Development Kit    
                                {JRE, Development Tools, IDE Support}
Java program excution process:
------------------------------
text editor             -   source code     -   sample.java
compiler   (javac)      -   byte code       -   sample.class   
                    (byte code is not in the form of 0's & 1's)

is this sample.class is targeted to one particular O/S ?
NO.

sample.class is not an executable program.

byte code   --> JVM (Java Virtual Machine) -> JVM will convert the byte code 
        into native machine code (sequence of 0's & 1's understood by that particular
        O/S in which the program is executed)
        the program is executed.

        machine code is generated ON-THE-FLY.

Java is platform (means o/s) independent language.

is JDK  common for all O/S? -   (platform dependent)
    NO
is JRE  common for all O/S? -   (platform dependent)
    No
is JVM  common for all O/S? -   (platform dependent)
    NO

BYTE CODE is the only one component which is platform independent.

is Native machine code common for all O/S?
    NO


JDK   (Java Development Kit)  
    for developers.
    lot of tools to develop java applications.
    
    javac   -   java compiler
    java    -   interpreter
    javadoc -   to create HTML documentation of a project
    javap	-	disassembler
    jdb     -   java debugger
    appletviewer
	jar		


JRE   (Java Runtime Environment)
    JRE provide JVM + other libraries


Features of Java:
-----------------
1. platform independent
2. object oriented 
3. secured
        no explicit pointers in java.
        java programs run inside a special environment i.e. JVM.
        JVM will talk to O/S.
        (JVM is a collection of programs - class-loader, byte-code-verifier, garbage-collector)
4. robust
        means fault-tolerant, strong, vigour and healthy.
        a. exception handling
        b. automatic garbage collection
        c. strong type checking.

5. self-documented (open source)
    source code is visible to anyone.
6. architectural neutral
7. compiled and interpreted


CODING STANDARDS / BEST PRACTICES
1. maintain proper indentation.
2. naming conventions

Java Tokens
-----------
smallest element in the program.


1. identifier
        it is a name given to variables, class, method names, package etc.,

        variable, method names must follow camel notation
            first word is in lowercase.
            from the second word onwards use first letter of each word is in uppercase
            and rest in lower case.

            eg:
                length
                lengthOfRectangle
                circleArea

                acceptData()
                showMinMaxInArray()
        
        class names, file name and project must follow pascal notation.
        (first letter of each word in uppercase and the rest in lowercase).
            eg:
                ArrayIndexOutOfBoundsException
                RuntimeException
                String
				System


        package name
            always in lowercase
            there are often abbreviated.
            eg:
                io
                lang
                awt
                util
                
        constants
            always be in uppercase.
            it is a name given to literal.
            it is immutable.
            it is qualified with "final" keyword.
            they can be separated with an underscore.

            1. identifier
        it is a name given to variables, class, method names, package etc.,

        variable, method names must follow camel notation 
            first word is in lowercase.
            from the second word onwards use first letter of each word is in uppercase
            and rest in lower case.

            eg:
                length
                lengthOfRectangle
                circleArea

                acceptData()
                showMinMaxInArray()
        
        class names, file name and project must follow pascal notation.
        (first letter of each word in uppercase and the rest in lowercase).
            eg:
                ArrayIndexOutOfBoundsException
                RuntimeException
                String

        package name
            always in lowercase
            there are often abbreviated.
            eg:
                io
                lang
                awt
                util

        constants
            always be in uppercase.
            it is a name given to literal.
            it is immutable.
            it is qualified with "final" keyword.
            they can be separated with an underscore.

            final double PIE = 3.14;
                    PIE is a constant.
                    3.14 is literal

            final int PASS_MARKS = 35;
            final int MAX_MARKS = 100;
            final int BATCH_CAPACITY = 40;
            
2. keywords
        these are also reserved words.
        eg: if, switch, for, while
            int, float, double

3. operators
        unary operators
           which takes only one operand.
           ++   --  !    
        binary operators
            it takes two operands
            all the remaining 
        ternary operator
            which takes three operands.
            conditional operator


        a) arithmetic operators :   +   -   *   /   %
        b) relational operator  :   >   <   ==  >=  <=  !=
        c) logical operators    :   &&  ||  !
        d) conditional operator :   (condition) ? true-statment : false-statement;
        e) assignment operator  :   =   +=  -=  *=  /=  %=
        f) increment / decrement :  ++, --
        g) bitwise operators    :   refer your self.
        h) misc. operators      :
                []
                ()
                <>
                ,
                .
                ;
                instanceof
4. literals
        any hard coded value.

        doule area = 3.14*radius*radius;

        3.14 is literal.

        a) integer literals
                i) decimal literal      (0-9)
                    30, -5

                ii) binary literal      (0,1)
                    0b101011
                    int a = 0b101;

                    observe the 0b prefix here.

                iii) octal literal      (0-7)
                    int a = 0234;

                    observe 0 prefix.

                iv) hexadecimal literal (0-9, A-F)
                    int a = 0xABC;

                    observe 0x prefix
                
        b) floating point literals
                3.14
        c) character literals
                character is a single alphabet, single digit or single special symbol.
                it the charcater is enclosed within single quotes, it is character constant.

                'A'
                '7'
                '?'
                'AB'        invalid

                escape sequence characters:
                '\n'        new line character
                '\t'        tab


        d) string literals
                group of characters enclosed within double quotes.

                "srinivas"
                "49-53-20/25"
                "9247175823"
                "a"
				""              empty string

        e) boolean literals
                true, false


5. comments
        ignored by the compiler.

        end-of-line comment             //
        block comment                   /*  and */
        documentation comment           /** and */	
		
		double PIE = 3.14;
                    PIE is a constant.
                    3.14 is literal

            final int PASS_MARKS = 35;
            final int MAX_MARKS = 100;
            final int BATCH_CAPACITY = 40;
            
            double circumference = 2 * PIE * radius;

            keyword         double
            indentifier     circumference
            operator        =
            literal         2
            operator        *
            constant        PIE
            operator        *
            identifier      radius
            operator        ;


2. keywords
        these are also reserved words.
        eg: if, switch, for, while
            int, float, double

3. operators
        unary operators
           which takes only one operand.
           ++   --  !    
        binary operators
            it takes two operands
            all the remaining 
        ternary operator
            which takes three operands.
            conditional operator


        a) arithmetic operators :   +   -   *   /   %
        b) relational operator  :   >   <   ==  >=  <=  !=
        c) logical operators    :   &&  ||  !
        d) conditional operator :   (condition) ? true-statment : false-statement;
        e) assignment operator  :   =   +=  -=  *=  /=  %=
        f) increment / decrement :  ++, --
        g) bitwise operators    :   refer your self.
        h) misc. operators      :
                []
                ()
                <>
                ,
                .
                ;
                instanceof
4. literals
        any hard coded value.

        doule area = 3.14*radius*radius;

        3.14 is literal.

        a) integer literals
                i) decimal literal      (0-9)
                    30, -5

                ii) binary literal      (0,1)
                    0b101011
                    int a = 0b101;

                    observe the 0b prefix here.

                iii) octal literal      (0-7)
                    int a = 0234;

                    observe 0 prefix.

                iv) hexadecimal literal (0-9, A-F)
                    int a = 0xABC;

                    observe 0x prefix
                
        b) floating point literals
                3.14
        c) character literals
                character is a single alphabet, single digit or single special symbol.
                it the charcater is enclosed within single quotes, it is character constantt.

                'A'
                '7'
                '?'
                'AB'        invalid

                escape sequence characters:
                '\n'        new line character
                '\t'        tab


        d) string literals
                group of characters enclosed within double quotes.

                "srinivas"
                "49-53-20/25"
                "9247175823"
                "a"             
                ""              empty string

        e) boolean literals
                true, false

5. comments
        ignored by the compiler.

        end-of-line comment             //
        block comment                   /*  and */
        documentation comment           /** and */



                                data types   
                                ----------
    primitive types
        numeric 
            integral
                byte        1
                short       2
                int         4
                long        8
            floating-point
                float       4
                double      8
        non-numeric
                char        2
                boolean     1 bit   -   true, false
                
                in java, true means not 1 and
                false means not 0.
                true, false are literals.

                void    
                	generally used to specify the return type of a function.
    
    user-defined types
        class
        interface
        enum
		annotation
------------------------------------------------------------------------------------------------------------

Eclipse IDE   (Java SE and Java EE)

package:
    it is represented as folder in O/S.
    collection of classes, interfaces and sub packages.

package name:
    reverse of the domain name.
    1) com.vev.tsw.ui

in java, there is no function. we have methods only.

method overloading:
    when two methods have the same name but with different parfameter list.

control structures:
-------------------
if      : bi-directional decision making statement.
          data types permitted - int, long, short, byte
                                 float, double, char 

switch  : multi-directional decision making statement.
          [data types permitted - int, long, byte, short, char, float, double, boolean.]

for     : to repeat the statements for a finite number of times.
while   : to repeat the statements for a indefinite number of times.
do..while : to execute the statements atleast once

break
continue

labelled break and labelled continue - explore yourself


How do you accept data from the user?
--------------------------------------
    Scanner scan = new Scanner(System.in);

    System.in means accept data from the keyboard.
    
    nextInt()
    nextDouble()
    next()
    nextLine()

    Scanner class is available in java.util package.

    import java.util.Scanner;

    (or)

    type the fully qualified name.
    java.util.Scanner scan = new java.util.Scanner(System.in);


                                    arrays
                                    ------

linear collection of homogeneous data items stored under single name.
0 based index.
every array in java is an object.   
array is provide a special property (field) with the name "length", that return no. of cells
in the array.

if we try to access an element with an invalid index, leads to an exception.
"ArrayIndexOutOfBoundsException"

types of arrays:
-----------------
1) single dimension
2) multi-dimension
3) jagged 

single dimension:
-------------------
declaring:
----------
    datatype [] arrayName;
    (or)
    datatype arrayName[];

    just by declaring, no memory is allocated.

eg:
    int [] arr;

allocating memory:
------------------
    arrayName = new datatype[size];
eg:
    arr = new int[5];

    whenever we use "new" keyword, the memory is allocated dynamically and stored in a special
    memory area known as "heap".

declaring and allocating :
----------------------------
    datatype [] arrayName = new datatype[size];

eg:
    int [] arr = new int[5];

initialize an array:
---------------------
    int []  arr = {10,20,30,40,50}; 

enhanced for loop:
------------------
for  (datatype   var  :  array) {
    statement(s);
}

 there is no concept called "index".
	Enhanced for loop offer better performance than classic for loop.
	loop variable is not "int" unlike as in classic for loop.
	type of the loop variable is same as the type of array.
	We cannot process few elements in the array.

    it is used to traverse an entire array or a collection in forward-only direction.

write a program to find min, max of an array.

jagged array:
-------------
it is a multi-dimension array, contain different no. of columns in each row.

                                        Command Line Arguments
                                        ----------------------

public static void main(String [] args) {

}

we cannot define main method like this ..
public static void main() {

}
it is treated as another method.


command line arguments are used to give inputs (parameters) to the main() method.
it is another way of accepting data.

write a program to print all command-line arguments.

write a program to accept two numbers and an arithmetic operation (ADD, SUB, MUL, DIV)
using command line arguments and perform the operation and print the result.

is int a primitive type ?	
		yes`
is String a primitive type?
		no
		String is a pre-defined class, it is a user-defined type.

How do you convert data of String to primitive type int?
    Integer -> parseInt(String form int)
    eg: 
        "10"    =>  Integer.parseInt("10") => 10
        "5"     =>  Integer.parseInt("5") => 5
        "ADD"   =>  

    Double.parseDouble(String form double)

        "10.5"  =>  Double.parseDouble("10.5") => 10.5
    
    for all illegal value, we get NumberFormatException.


                                             VarArgs
                                             -------
write a function to return the sum of the values passed as arguments to the function.

 it represents indefinite number of arguments
    it is represented with ... (three dots)
    three dot symbol "ellipsis".

    we can pass any number of arguments while calling this type of function.

    Command Line Arguments can also be represeted as Variable Arguments.


                                        Method Overloading
                                        ---------------------
when two or more methods are having the same name but with different set of parameters ,
then it is said to be funcmethod overloading.

int area(int a, int b) {

}

int area(int a, double b) {

}       // allowed

int area(double a, int b) {

}   // allowed

double area(int a, int b) {

}   // NOT ALLOWED - return type is not considered


Arrays class: (java.util package)
----------------------------------
provide many util methods to simplify our programming.
explore these methods.

1) copyOf()
2) binarySearch()
3) sort()
4) fill()
5) toString()




equals()
    equals() compare references only

=========================================================================================================

                                    OOPS    (Object Oriented Programming System)
                                    --------------------------------------------
It is a programming paradigm (methodologies)
    + monolithic programming    (eg: assembly language, basic)
    + procedure oriented        (eg: cobol)
    + structured programming    (eg: 'C')
    + object oriented programming. (eg: C++, Java, C#, Python)

Advantages of OOP:
-------------------
+   code re-usability
+   security

class:  It is a user-defined datatype that represent an entity in terms of properties (data members) 
        and behaviours (methods)
        classes we are creating, also known as POJO (Plain Java Old Object).
        classes are also known as model, dto, entity etc.,
object: It is a runtime instance of class.

features of OOPS:
-----------------
+ encapsulation : providing setters and getters, so that other classes can access the private data
                  using these methods.
+ data hiding : making data members as private

+ abstraction : behaviour hiding
+ inheritance
+ polymorphism
+ persistence


class ClassName {
    [data members]
    [methods]
}

creating object:
----------------
ClassName   objectName;
objectName = new ClassName();

access specifiers (access modifiers):
---------------------------------------
1) default 
2) private  :   members under this access can be used only within the class in which they are defined
3) public   :   members under this access can be used in any class
4) protected

setters (mutators) and getters (accessors):


"this" reference:
--------------------
it refer to the "implied object".
implied object is the one through which a method is executed currently.


data members are stored separately for each object.
methods are stored only once and they can be accessed by all objects.


static members:
-----------------
static means "sharable".
1) static data members      (class variables)
    + when a data member is declared as "static", it is stored only once in the memory
      and that is shared across all objects of the class.

2) static methods
    + it allow only static data members or static methods
    + it can be called directly with the class name. no need to use any object to call static method.
    + "this" keyword is not allowed in a static method

3) static block
4) static class         (refer it)


constructor:
-------------
1) it is a special method which is automatically executed whenever an object is created.
2) it should have the same name as that of class.
3) if no constructor is written, java create a default constructor on it's own.
4) it can take parameters.
5) we cannot return any value from a constructor, and should not have return type as "void"
6) a class can have many constructors. this is known as "constructor overloading".

type constructors:
-------------------
1) default constructor   (no-parameter constructor)
2) parameter constructor
3) copy constructor : it is a special constructor that takes object of the same class as parameter.

OOAD  (Object Oriented Analysis and Design):
--------------------------------------------
UML  stands for Unified Modelling language

1) class diagram

==========================================================================================================

Inheritance:

	creating a new class (sub class) from an existing class (super class).
    sub class can make use of all features of super class as well as any extra features that are
    added to it.
    it represent "is-A" relation ship.
    it is mainly for code-reusability.

	types of inheritance:
	----------------------------
	1) simple	        A <- B
    2) hierarchical	    A <- B, A <- C
    3) multi-level      A <- B <- C
    4) multiple	        (not available for classes)
	
    the keyword "extends" is used to derive a sub class from a super class.
	java doesn't support multiple inheritance for classes that means a class can have only one
    superclass.
	
    Note:
    ------
	Inheritance will share only the definition but not the existence.

java.lang.Object class:
-----------------------
* It is a universal super class of every class in java (pre-defined or user-defined)

methods:
1) public String toString()
        it is written such a way that classname@hashcode is returned.

2) public int hashCode()
        return the hashcode in decimal representation

3) public boolean equals(Object obj)
        return whether two objects are equal or not.
        the default implementation is comparing references.


method overriding:
-------------------
when a sub class contain a method which has the same signature as that of another method of it's
super class, then the sub class method is said to be overriding method.

"@Override" annotation can be used on method overriding.
if overriding is not done propertly, @Override will raise an error.


constructor phenomenon:
----------------------------------
	when an object is created, the constructor of that class is called.

	when an object of sub class is created, super class constructor is called first and 
    then the sub class constructor is called. This hold true for any levels of inheritance.

	when a sub class object is created with

	i) default constructor		then the super class default constructor is called.
	ii) parameter constructor	then the super class default constructor is called.
	iii) copy constructor		then the super class default constructor is called.

"super" keyword:	("super" reference)
----------------------------------------------------
	1) it is used to call the constructor of super class from the constructor of sub class.
	2) This is used exclusively call a parameter constructor or copy constructor of the 
        super class from sub class constructor.
	3) if super() has to be used, it must be the first statement in the code block.
	4) this() and super() cannot be used at a time.	(mutually exclusive)
	5) "super" keyword can be used to call an overriding function of super class in the sub class.

class A {
    public A() {
        System.out.println("A");
    }
}
class B extends A {
    public B() {
        System.out.println("B");
    }
    public B(String msg) {
        System.out.println(msg);
    }
    public B(B obj) {
        System.out.println("copy constructor");
    }
}
class C extends B {
    public C() {
        System.out.println("C");
    }
}
class Main {
    public static void main(String [] args) {
        B obj2 = new B();               // A  B
        B obj3 = new B("hello");        // A  hello
        B obj4 = new B(obj2);           // A  copy constructor
    }
}


Abstract Polymorphism	(Abstraction)
---------------------------------------------------------
abstract means "incomplete or unclear". It is an idea but we don't know how to implement.
abstraction means "behaviour hiding".
abstraction is "disclosing only required details and hiding the background implementation".

abstract class:
--------------------
	It is a class which should not have objects allocated.

	School Automation
		School	=> Domain
		Teacher, Student, Principle	=> Domain Entities
	
		common properties	=>  

		Person ==> name, age, phone, address, date of birth, weight, height, blood group

		Teacher extends Person	    => salary, subject, 
		Principle extends Person	==>	....
		Student extends Person      ==> fee, class, section

        In this scenario, we never need to create an object for Person.
        so, Person class can be declared as an abstract.

	to make a class abstract, it must be defined with an "abstract" keyword.
	we cannot instantiate (create an object) an abstract class.

abstract method:
----------------------
	It is a method which do not have any implementation (i.e., definition)

   	eg:	abstract class Shape 
			abstract 	area()	: 
			abstract 	perimeter() :
			abstract	volume();


	    abstract class	Rectangle	extends	Shape {
			@Override
			area() {
				...
			}
			@Override
			perimeter() {
				..
			}
		}

		class	Cuboid	extends	Rectangle {
			@Override
			volume() {
				....
			}
		}

	1) an abstract method must be written only inside an abstract class.
	2) but an abstract class need not contain any abstract method.
	3) all sub classes of abstract class, must implement (override) all abstract methods. 
       if not, the sub class must also be marked as "abstract".

abstract class A {
    abstract void show();
}

class B extends A {
    @Override
    protected void show() {               
        System.out.println("B");
    }
}

class Test {
    public static void main(String [] args) {
        B obj = new B();
        obj.show();
    }
}

error:
    cannot reduce the visibility of the inherited method.

Type Casting:
-------------
	Converting one datatype to another.

	2 types.

	a) Narrowing	(demotion)		explicit
	b) Broadening	(promotion)		implicit


	primitive types:
	-------------------
	b) broadening:
	    -----------------
	int x = 45;
	double d = x;		(implicit)	- broadening

	double d2 = 67;		// OK
	int y = '@';		// OK

	char -> int -> double

	a) narrowing: (explicit):
	------------------------------
	int x = 45.0;		// error
	int x = (int)45.0;		// OK

	char ch = (char)156;	// OK


Referencing:
------------

	In inheritance, super class reference variable can hold sub class objects.
	Vice Versa  is NOT TRUE.

			                    Employee
			                        |
            --------------------------------------------
	        |					                        |
         Manager				                ContractEmployee
	        |
       Managing Director

	Employee emp1 = new Employee();	
	Employee emp2 = new Manager();		
	Employee emp3 = new ContractEmployee();	
    Employee emp4 = new ManagingDirector();	
	
	Manager m1 = new Manager();		
	Manager m2 = new ManagingDirector();	

	Manager m3 = new ContractEmployee();	
	ContractEmployee ce = new Employee();	


	user-defined data types:
	-----------------------------------------

	ContractEmployee ce1 = new Employee();		
	ContractEmployee ce2 = emp3;			

	ContractEmployee ce2 = (ContractEmployee)emp3	
	
	ContractEmployee ce3 = emp4;			
	ContractEmployee ce2 = (ContractEmployee)emp4	

	Manager m1 = (Manager)emp2;			
	Manager m2 = (Manager)emp3;			
	Manager m3 = (Manager)emp4;			

	
final keyword:
------------------
1) final class : it cannot be inherited.
2) final method : it cannot be overridden.
3) final variable : value of which cannot be modified. (constants)


Best Practices:
--------------------
whenever we create a constant, it is recommended to mark it as "public static final".
	final because it must be a constant.
	static because a constant will have only value for all objects of the class.
	public because however it cannot be modified.

class               : entity
abstract class      : semi-defined entity
interface           : ROLE (responsibility)

==================================================================================================

interfaces:
-----------
It is a user-defined datatype (like class) that represents a ROLE and can contain 
only abstract methods and static final variables (till JDK 1.7)
interface will not have properties.
we cannot instantiate (creating an object) an interface.



 interface                              Abstract Class
 ------------------                    -------------------
 no fields                              may have fields
 only public members                    any type of members
 
 represent Role                         represent Entity (semi-defined)
 
 one entity can 
 have any number of roles

 to achieve multiple inheritance


enum:
------
it is a user-defined datatype that represent possible values of a property (contain fixed set of constants)
"enum" stands for "enumeration".

It can be used for day of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY and SATURDAY) , 
directions (NORTH, SOUTH, EAST and WEST), Season (WINTER, SPRING, SUMMER, FALL), gender (MALE, FEMALE)   etc. 

The java enum constants are static and final implicitly. 

enum ensures type safety.

methods:
---------
1) values()
2) ordinal()
3) name()

 
static class

 Not all classes can be static.

 Java allows us to create one class inside another class, also known as inner class.
 only such inner class can be marked as static,
 and static inner classes are called nested classes.

 class Demo{
    class InnerClass{

    }

    static class NestedClass{

    }
 }


Java 8 enhancements to an interface.
------------------------------------
 default methods

 unlike method in a interface that are forced to be abstract,
 if a method is marked with keyword 'default', then the
 default method can have implementation

 interface A {
    public abstract void m1();
    public abstract void m2();


   default void m3() {
       // implementation code
   }

   static void m4() {

   }

 }

 class B implements A {
     @Overriding
     void m1() {

     }

     @Overiding
     void m2() {

     }

     @Override
     void m3() {
         // sub class specific
     }
 }

 B obj = new B();
 obj.m1()
 obj.m2()
 obj.m3()

 A.m4()     ==> since m4 is static method, we can call by using interface name.



 100 implementation classes 



						                Built-In Packages
						                ------------------
                                        (Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Thread
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.util
    Scanner
    Date        (deprecated)
    Calendar    (deprecated)
java.io
    BufferedReader

to use any class, we need to specify fully qualified class name.(eg: packagename.classname) 
or import them.

java.lang is the default package. it is automatically imported for every program.

1 java.lang.System class:
   -------------------------------

	class variables			              object
	-------------------				    ---------
	public static java.io.InputStream		in
	public static java.io.PrintStream		out
	public static java.io.PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    String getEnvironmentVariable(String varName);
    void setEnvironmentVariable(String varName,String value);


java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            Math.sin(30)    =>  ???
            Math.sin(Math.toRadians(30))    =>  0.5

        double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            Math.ceil(11.2) => 12
		floor() : return previous integer
            Math.floor(11.9) => 11
		round() 
            Math.round(11.2) =>  11
            Math.round(11.9) =>  12

		abs()
		toRadians()
		toDegrees()

java.lang.String
---------------------
	String is immutable	(not modifiable).
    what is immutability?
        String s1 = "Hello";
        String s2 = new String("World");
        String s3 = s1 + s2;

	creating object:
	---------------------
	1) String	str;
	2) String	str = new String();
	3) String	str = "hello";
	4) String	str = new String("hello");
	5) String	str1 = str;
	6) String	str1 = new String(str);


	methods:
	-------------
	1) length()		2) toUpperCase()		3) toLowerCase()
	4) indexOf(String)	5) lastIndexOf(String)		6) startsWith(String)
	7) endsWith(String)	8) contains(String)		9) charAt(index)
	10) substring(start_index [, end_index] )		11) split()
	12) equals(String)	13) equalsIgnoreCase(String)	14) compareTo(String)
	15) valueOf()		16) format()        17) replace(old_char, new_char)

    18) join()  - JDK 1.8

    "+" string concatenation operator


String constant pool (String literal pool)
------------------------------------------
    This is a special memory used to store string constants.


java.lang.StringBuffer and java.lang.StringBuilder:
------------------------------------------------------------------
	StringBuffer is thread-safe. (synchronized)
	StringBuilder is not thread-safe.

	They are mutable (modifiable).

	a) capacity()
	b) append()
	c) insert()
	d) delete()
	e) reverse()

StringJoiner (jdk 1.8)
    used to join group of Strings.

    StringJoiner(delimiter)
    StringJoiner(delimiter, prefix, suffix)
    merge()

StringTokenizer (java.util)         -- Legacy Class
    to split the string into words based on the delimiter given.

    StringTokenizer(string, delimiter, boolean returnDelims)

    hasTokens()
    nextToken()

    Since it is a legacy class, we can use split() of String class, which offer better
    performance.



Wrapper Classes                     static method
---------------------               ---------------------------------
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long

every wrapper class provide two constants.
    MIN_VALUE 
    MAX_VALUE

 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing

static import: (JDK 1.5)
------------------------
    java.lang.Math class provide static methods.
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


    import java.util.Scanner;       // recommended
    import java.util.*;             // bad coding practice


Exception Handling
--------------------------------
    Exception is an object that represents a situation
    where the application broke down.

                java.lang.Throwable (i)
                        |
                        |
            ---------------------------------
            |                               |
            java.lang.Error         java.lang.Exception
                                            |
                                            |
                                    java.lang.RuntimeException
    
    Exception classes that are derived from Exception class - CHECKED
    Exception classes that are derived from RuntimeException class - UNCHECKED


    1) try : contain the code where the exception can be generated.
    2) catch : contain statements that are to be executed when the specified exception occurred.
            
            the most relevant exception classes mention first.
            least relevant exception mention next.

    a try block must follow an immediate catch block (or) a finally block.

            try {
                ..
            } finally {
                ...
            }

    a try can have many catch blocks.
    a try block can have another try block within it.

    3) finally : contain the code to be executed whether an exception or occurred or not.


    UnChecked Exceptions

        unchecked exceptions are 
        NOT INFORMED BY THE IDE / COMPILER. 

        we are not supposed to handle UnChecked Exceptions
        because they can be avoided through "Defensive programming".

            Employee emp;
            emp = new Employee();
            emp.setName("Lavanya"); //NullPointerException is avoided.

            public void processHike(Employee emp){
                if(emp!=null){
                    emp.setBasic(emp.getBasic()+10000); // NullPointerException is avoided
                }
            }

        
        Checked Exceptions

            all exception classes that are NOT
            derived from RuntimeException class are
            identified as Checked exceptions.
        
            if you do not handle checked exceptions, the compiler will give errors.

            if a method is supposed to raise
            checked exception, the compiler will
            force us to handle checked exceptions

            checked exceptions must be handled, they cannot be avoided.

            eg:
                download a file,                IOException
                database connection broken.     SQLException

                try{
                    ....the code that may raise an exception     
                } catch(Exception exp){
                    ..do the alternate or display a user understandable message.
                }

======================================================================================================
        User Defined Exceptions

            1. create a class which should be derived from java.lang.Exception or java.lang.RuntimeException
            2. write a constructor that takes a String parameter.
            3. call the super class constructor by passing this String to it.

            create a checked exception
            
            eg:
                class MyCheckedException extends Exception {
                    
                    public MyCheckedException(String errMsg){
                        super(errMsg);
                    }
                }

            create an unchecked exception

            1. create a class which should be derived from java.lang.RuntimeException
            2. write a constructor that takes a String parameter.
            3. call the super class constructor by passing this String to it.

            class MyUnCheckedException extends RuntimeException {
                  
                MyUnCheckedException(String errMsg){
                    super(errMsg);
                }
            }

            "throw" keyword is used to raise an exception
                throw new MyCheckedException("error message");

            "throws" keyword is used to tranfer (delegate) the exception handling responsibility
            from a method to its caller method.


    String getMessage()         (java.lang.Throwable)
	void printStackTrace()      (java.lang.Throwable)



JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

    try {
	    statement(s)
    } catch (Exception-1   |  Exception-2  |  Exception-3    obj) {
	    statement(s)
    }

b) try-with-resources

    try (declare closable resourceses here....){
                    ........................
    }catch(....){

    }

    the closable resource will be close automatically.

    a Resource has to implement java.lang.Closable interface
    to be recognized as closable.



java.time package (JDK 8) - DateTime API
----------------------------------------
	+ LocalDate
	+ LocalTime
	+ LocalDateTime
	+ DateTimeFormatter
	+ Duration
	+ Period


    LocalDate
        default format is yyyy-MM-dd.

        now() : static method that return system date.
        of(year, month, day)
        parse(string-form-date)

        getDayOfMonth()
        getDayOfYear()
        getMonthValue()
        getYear()

        plusDays()
        plusMonths()
        plusYears()

        now(), of(), parse() are known as "Factory method", which will return object of the same class.

    LocalTime
    LocalDateTime

    DateTimeFormatter
        format()
        ofPattern(formatString)
    Duration
    Period
        between(localDate1, localDate2)
        getDays()
        getMonths()
        getYears()

    ZoneId
        of()

    DateTimeFormatter                                        
        .ofPattern(String pattern);

            d           day                             
            dd          day with leading zeros          
            ddd         day in words

            M           month
            MM          month with leading zeros
            MMM         Three lettered Month name
            MMMM        comple month name

            yy , yyyy   Year

            h,hh        hour in 12 hr format
            H,HH        hour in 24 hr format

            mm          min

            ss          sec


                                   Regular Expressions
						           --------------------
                                    (java.util.regex)

A regular expression defines a search pattern for strings. The short form for regular expression 
is regex. 
The search pattern can be anything from a simple character, a fixed string or a complex 
expression containing special characters describing the pattern. 
The pattern defined by the regex may match one or several times or not at all for a 
given string.
Regular expressions can be used to search, edit and manipulate text.
It is mainly for validations.


	.	any single character
	\d	single digit from 0 - 9
	\D	single character except digit
	\s	space
	\S	single character except space
	[ ]	single character of given choice or range
		eg: 	[A-Z]           any uppercase alphabet
			    [abcdA-E]       a,b,c,d,A,B,C,D,E
			    [0-9]           any digit
	[^ ]	single character except within the range
		eg:	[^ 1-5]         any digit other than 1,2,3,4,5

occurance indicaters:
	
	?	0 to 1 time
	*	0 to any no. of times
	+	1 to any no. of times
	{ n }	exactly 'n' times.
	{ , m}	max. 'm' times and min. is '0'.
	{n, m}	min. 'n' times and max. is 'm' times.

eg:

	mobile number	"\d{10}"
	but in java, we must say "\\d{10}"

	but first digit cannot be 0. so , it must be given as ...	"[1-9]\\d{9}"

	vehicle number	eg: AP31 CK 9916
				        AP31CK   1
        [1-9]

		[A-Z]{2} \d{2} [A-Z]{2} \s\d{, 3}

	aadhar id		eg: 8414 6320 8422
		\d{4} \s \d{4} \s \d{4}
        [1-0]\d{3} \s \d{4} \s \d{4}

java.util.regex package:
------------------------------

a) Pattern class:		to represent regular expression.
-----------------------
	methods:
	-------------
	i)	public static 	Pattern 	compile(String   regexPattern)
			it checks whether any small part of pattern is matching or not.
	
b) Matcher class:
    methods:
    i) public static   boolean 	matches(pattern, String)
			it checks whether the entire string should exactly match the pattern.

split method (of java.lang.String)
    i) String [] split(String)
            will extract the String based on the pattern specified.


    public class RegExDemo {
        public static void main(String [] args) {
            String mobile = "9247175823";
            String mobile2 = "92471";


            // System.out.println(mobile.matches("[1-9][0-9]{9}"));
            // System.out.println(mobile.matches("[1-9][0-9]{9}"));

            Pattern mobP = Pattern.compile("[1-9][0-9]{9}");
            Matcher m1 = mobP.matcher(mobile);
            System.out.println(m1.matches());

            String passage = "I have to port 9247212540 into a new 9247212539";
            Matcher m2 = mobP.matcher(passage);
            System.out.println(m2.find());
        }
    }


                                    Generics
							        --------
These are called as ADT	(abstract data types)

when there is a logic which is indepedent of datatypes, then we can use ADT. 
eg: Sorting on int's, float's, double's or char's are same.
generics are implemented using angular bracktes. < >. The imaginary datatype is represented as T. 
eg: <T>.
if we have two imaginary datatypes then <T1, T2>

generics do not support primitive types.
T can be Book, Car, ComplexNumber, Employee etc.,
but not with int, char, float, double.
if it is inevitable, we may use Wrapper classes.


                                    Collection API (Collection Framework)
                                    --------------------------------------
                                            (java.util package)

API  (Application Programming Interface)
    It is a group of pre-defined interfaces, abstract classes.
    They provided implementation classes also.


It is a structured way of storing group of objects.

Collection means group of objects
There are two types of data structures

Linear:  
	Objects are stored in a linear fashion
	Objects can be numbered which we call as index
	Linear data structure supports index based operations.

Advantages:
	Linear data structure supports sequential access 
	Also Supports random access.

Non linear:
    Not in linear fashion so we do not have index here and 
    thus we cannot access them randomly.

Few of the classes are grouped into collection

Collections are divided into 3 parts:
	
	a) Declaration Part: 
	Here we have interfaces 

                               Collection API Diagram


                                       Iterable (I)
                                            |
                                       Collection (I)
                         ___________________|________________________           
                        |                   |                       |
                    List (I)               Set (I)               Queue (I)
        ________________|____________________
        |                   |               |
    ArrayList (C)       LinkedList (C)    Vector (C)




	b) Implementation part: 
		Set<-- HashSet,LinkedHashSet.
		SortedSet<---------Treeset
		List<------ArrayList,LinkedList


	Collection interface methods:
       	{ size(), contains(object), add(object), remove(object) }

    List allow duplicate elements.
	ArrayList-->interally uses an expandable array to store the elements.
	If there are too many insertions and deletions LinkedList is used.
	If there are too many retrievals arrayList will perform better.
    Vector is a legacy class.

    ArrayList class
        DEFAULT_CAPACITY = 10
        elementData is an Object[] where the data of array list is stored.
        everytime the grow() method is called, the array is extended by 50%.
        newCapacity = oldCapacity + (oldCapacity >> 1);

        methods:
        --------
        add()
        isEmpty()
        size()
        remove(index)
        set(index, value)
        get(index)
        clear()
        equals()
        indexOf(value)
        lastIndexOf()
        toArray() : convert array list into an array.
        sort()

    LinkedList:
    -----------
        it is in the form of linked list.
        it can be used when you are having frequent updations.

        1) addFirst()
        2) addLast()
        3) removeFirst()
        4) removeLast()

    Vector:
    -------
        default capacity = 10
        when a new elements is added when the existing cells are filled, the capacity is
        DOUBLED.

    What is the difference between Vector and ArrayList?

    Iterator:
        which allows to iterate through a collection.

        iterator()
        hasNext()
        next()

    What is the difference between iterator and enhanced for?


Set:
-------
    Set will not allow duplicate elements where as list will allow the same.

	HashSet --> Order is undefined.
	LinkedHashSet--> Insertion Order
	TreeSet-> maintains sorted order
        null is not allowed in TreeSet. we get NullPointerException.

    index based retrieval is not possible.

Queue:
    FIFO    (first in, first out)
    insertions will happen at begining.
    deletions also happend at beginning.
PriorityQueue

ArrayDequeue



Map:
------
			  Map Diagram 

	Maps are used to store key-value pair data. (It is also called as Dictionary)
	In map, keys are not sorted in order
	In sorted map, keys are in sorted order 
    key cannot be duplicated.
    value can be duplicated.
	index based retrieval is not possible.
    value can be retrieved if a key is given.

    put(key,value)
    get(key)
    set(key,value)
    remove(key)
    size()
    contains(key)
    keySet() : return all keys
    values() : return all values
    containsKey()
    containsValue()
    entrySet() : entry means combination of key and value
    

    implementation classes:
        HashMap
        LinkedHashMap
        TreeMap
        HashTable


java.util.Collections class:
----------------------------
1) sort()
2) binarySearch(list, key)
3) fill(list, object)

    java.lang.Comparable interface:
    --------------------------------
    it contain only one abstract method
    
    public int compareTo(T object)

    The class should know how do you want to sort.  (intenally)
    The class must implement java.lang.Comparable interface.

